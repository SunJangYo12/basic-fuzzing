From: <Saved by Blink>
Snapshot-Content-Location: https://h0mbre.github.io/Fuzzing-Like-A-Caveman-6/
Subject: Fuzzing Seperti Manusia Gua 6: Binary Only Snapshot Fuzzing Harness | Antarmuka Mesin Manusia
Date: Wed, 20 Nov 2024 22:22:07 -0000
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----MultipartBoundary--UL36Vsa5HO0TbB8lkGoRqqA9W8Bsi7tgULfaVjMKY5----"


------MultipartBoundary--UL36Vsa5HO0TbB8lkGoRqqA9W8Bsi7tgULfaVjMKY5----
Content-Type: text/html
Content-ID: <frame-107ACA783E040003FA329CB53E3F0435@mhtml.blink>
Content-Transfer-Encoding: binary
Content-Location: https://h0mbre.github.io/Fuzzing-Like-A-Caveman-6/

<!DOCTYPE html><html lang="id" class="translated-ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Fuzzing Seperti Manusia Gua 6: Binary Only Snapshot Fuzzing Harness | Antarmuka Mesin Manusia</title>
<meta name="generator" content="Jekyll v3.9.5">
<meta property="og:title" content="Fuzzing Like A Caveman 6: Binary Only Snapshot Fuzzing Harness">
<meta property="og:locale" content="en_US">
<meta name="description" content="Introduction It’s been a while since I’ve done one of these, and one of my goals this year is to do more so here we are. A side project of mine is kind of reaching a good stopping point so I’ll have more free-time to do my own research and blog again. Looking forward to sharing more and more this year.">
<meta property="og:description" content="Introduction It’s been a while since I’ve done one of these, and one of my goals this year is to do more so here we are. A side project of mine is kind of reaching a good stopping point so I’ll have more free-time to do my own research and blog again. Looking forward to sharing more and more this year.">
<link rel="canonical" href="https://h0mbre.github.io/Fuzzing-Like-A-Caveman-6/">
<meta property="og:url" content="https://h0mbre.github.io/Fuzzing-Like-A-Caveman-6/">
<meta property="og:site_name" content="The Human Machine Interface">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-04-02T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Fuzzing Like A Caveman 6: Binary Only Snapshot Fuzzing Harness">

<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="https://h0mbre.github.io/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://h0mbre.github.io/feed.xml" title="Antarmuka Manusia dan Mesin"><link type="text/css" rel="stylesheet" charset="UTF-8" href="https://www.gstatic.com/_/translate_http/_/ss/k=translate_http.tr.26tY-h6gH9w.L.W.O/am=DAY/d=0/rs=AN8SPfrCcgxoBri2FVMQptvuOBiOsolgBw/m=el_main_css"></head>
<body class="post-page"><header class="site-header">
    <div class="wrapper">
      <a class="site-title" rel="author" href="https://h0mbre.github.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antarmuka Manusia dan Mesin</font></font></a>
    </div>
  </header><main class="page-content" aria-label="Isi">
      <div class="wrapper">
        <article class="post main-content">
  <header class="post-header">
    <h1 class="post-title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuzzing Seperti Manusia Gua 6: Pengikat Fuzzing Snapshot Biner Saja</font></font></h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-04-02T00:00:00+00:00" itemprop="datePublished"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 April 2022
      </font></font></time></p>
  </header>
  <div class="post-content">
    <h2 id="introduction"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perkenalan</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sudah lama sejak terakhir kali saya melakukan hal semacam ini, dan salah satu tujuan saya tahun ini adalah melakukannya lebih banyak lagi. Proyek sampingan saya sudah mencapai titik akhir yang bagus sehingga saya akan memiliki lebih banyak waktu luang untuk melakukan penelitian dan menulis blog sendiri lagi. Saya berharap dapat berbagi lebih banyak lagi tahun ini.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salah satu pertanyaan paling umum yang muncul di kalangan pemula dalam fuzzing (yang jelas saya adalah salah satunya) adalah bagaimana memanfaatkan target sehingga dapat difuzz dalam memori, sebagaimana beberapa orang menyebutnya dengan cara 'persisten', untuk mendapatkan kinerja. Fuzzing persisten memiliki kasus penggunaan khusus di mana target tidak banyak menyentuh status global dari fuzzcase ke fuzzcase, contohnya adalah loop fuzzing ketat untuk satu API dalam pustaka, atau mungkin satu fungsi dalam biner.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gaya fuzzing ini lebih cepat daripada mengeksekusi ulang target dari awal berulang kali karena kita melewati semua syscall/rutin kernel berat yang terkait dengan pembuatan dan penghancuran struktur tugas.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, dengan target biner yang tidak memiliki kode sumber, terkadang sulit untuk mengetahui status global apa yang kita pengaruhi saat menjalankan jalur kode apa pun tanpa rekayasa balik yang berat (menjijikkan, kerja? menjijikkan). Selain itu, kita sering ingin mengaburkan loop yang lebih luas. Tidak banyak gunanya bagi kita untuk mengaburkan fungsi yang mengembalikan struct yang kemudian tidak pernah dibaca atau dikonsumsi dalam alur kerja pengaburan kita. Dengan mempertimbangkan hal-hal ini, kita sering menemukan bahwa pengaburan 'snapshot' akan menjadi alur kerja yang lebih kuat untuk target biner, atau bahkan biner produksi yang, kita memiliki sumbernya, tetapi telah melalui pabrik sosis sistem pembangunan perusahaan.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi hari ini, kita akan mempelajari cara mengambil target biner sembarangan yang mengambil berkas masukan dari pengguna dan mengubahnya menjadi target yang mengambil masukannya dari memori dan cocok untuk mengatur ulang statusnya di antara fuzzcase.</font></font></p>

<h2 id="target-easy-mode"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Target (Mode Mudah)</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk keperluan blogpost ini, kita akan memanfaatkan objdump untuk difuzz snapshot. Ini akan sesuai dengan tujuan kita karena relatif sederhana (berulir tunggal, proses tunggal) dan merupakan target fuzzing umum, terutama saat orang melakukan pekerjaan pengembangan pada fuzzer mereka. Inti dari ini bukanlah untuk membuat Anda terkesan dengan melakukan sandbox pada target yang gila seperti Chrome, tetapi untuk menunjukkan kepada pemula cara mulai berpikir tentang harnessing. Anda ingin membuat target Anda menjadi tidak dapat dikenali dari bentuk aslinya tetapi tetap memiliki semantik yang sama. Anda dapat berkreasi sesuka hati, dan sejujurnya, terkadang memanfaatkan target merupakan salah satu pekerjaan yang paling memuaskan terkait dengan fuzzing. Rasanya luar biasa berhasil melakukan sandbox pada target dan membuatnya bekerja dengan baik dengan fuzzer Anda. Mari kita lanjutkan.</font></font></p>

<h2 id="hello-world"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo Dunia</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah pertama adalah menentukan bagaimana kita ingin mengubah perilaku objdump. Mari kita coba menjalankannya di bawah </font></font><code class="language-plaintext highlighter-rouge">strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan membongkarnya </font></font><code class="language-plaintext highlighter-rouge">ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan melihat bagaimana perilakunya di tingkat syscall dengan </font></font><code class="language-plaintext highlighter-rouge">strace objdump -D /bin/ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Yang kita cari adalah titik di mana </font></font><code class="language-plaintext highlighter-rouge">objdump</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mulai berinteraksi dengan input kita, </font></font><code class="language-plaintext highlighter-rouge">/bin/ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam kasus ini. Dalam output, jika Anda menggulir ke bawah melewati hal-hal boilerplate, Anda dapat melihat tampilan pertama dari </font></font><code class="language-plaintext highlighter-rouge">/bin/ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stat("/bin/ls", {st_mode=S_IFREG|0755, st_size=133792, ...}) = 0<font></font>
stat("/bin/ls", {st_mode=S_IFREG|0755, st_size=133792, ...}) = 0<font></font>
openat(AT_FDCWD, "/bin/ls", O_RDONLY)   = 3<font></font>
fcntl(3, F_GETFD)                       = 0<font></font>
fcntl(3, F_SETFD, FD_CLOEXEC)           = 0<font></font>
</code></pre></div></div>
<p><strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingatlah bahwa saat Anda membaca ini, jika Anda mengikutinya di rumah, output Anda mungkin tidak sama persis dengan output saya. Saya mungkin menggunakan distribusi yang berbeda dengan Anda dan menjalankan objdump yang berbeda. Namun, inti dari blogpost ini adalah untuk menunjukkan konsep yang dapat Anda kreasikan sendiri.</font></font></em></strong></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya juga memperhatikan bahwa program tersebut tidak menutup berkas masukan kami hingga akhir eksekusi:</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>read(3, "\0\0\0\0\0\0\0\0\10\0\"\0\0\0\0\0\1\0\0\0\377\377\377\377\1\0\0\0\0\0\0\0"..., 4096) = 2720<font></font>
write(1, ":(%rax)\n  21ffa4:\t00 00         "..., 4096) = 4096<font></font>
write(1, "x0,%eax\n  220105:\t00 00         "..., 4096) = 4096<font></font>
close(3)                                = 0<font></font>
write(1, "023e:\t00 00                \tadd "..., 2190) = 2190<font></font>
exit_group(0)                           = ?<font></font>
+++ exited with 0 +++<font></font>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini penting untuk diketahui, kita perlu memanfaatkan kemampuan untuk mengemulasikan berkas input dengan cukup baik karena objdump tidak hanya membaca berkas kita ke buffer memori dalam satu kali pengambilan atau </font></font><code class="language-plaintext highlighter-rouge">mmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berkas input. Objdump terus membaca dari berkas tersebut melalui keluaran </font></font><code class="language-plaintext highlighter-rouge">strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kita tidak memiliki kode sumber untuk target, kita akan memengaruhi perilaku dengan menggunakan </font></font><code class="language-plaintext highlighter-rouge">LD_PRELOAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objek bersama. Dengan menggunakan </font></font><code class="language-plaintext highlighter-rouge">LD_PRELOAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objek bersama, kita seharusnya dapat mengaitkan fungsi pembungkus di sekitar syscall yang berinteraksi dengan berkas masukan kita dan mengubah perilakunya agar sesuai dengan tujuan kita. Jika Anda tidak terbiasa dengan penautan dinamis atau </font></font><code class="language-plaintext highlighter-rouge">LD_PRELOAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ini akan menjadi titik perhentian yang baik untuk mencari informasi lebih lanjut di Google sebagai </font></font><a href="https://tbrindus.ca/correct-ld-preload-hooking-libc/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">titik awal yang bagus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sebagai permulaan, mari kita </font><font style="vertical-align: inherit;">muat objek bersama </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, World!</font></font></em><font style="vertical-align: inherit;"></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat memanfaatkan </font></font><code class="language-plaintext highlighter-rouge">gcc</code> <a href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atribut Fungsi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> agar objek bersama kita mengeksekusi kode saat dimuat oleh target dengan memanfaatkan </font></font><code class="language-plaintext highlighter-rouge">constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atribut tersebut.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi kode kita sejauh ini akan terlihat seperti ini:</font></font></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 
Compiler flags: 
gcc -shared -Wall -Werror -fPIC blog_harness.c -o blog_harness.so -ldl
*/</span><font></font>
<font></font>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> /* printf */</span><span class="cp">
</span>
<span class="c1">// Routine to be called when our shared object is loaded</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">_hook_load</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"** LD_PRELOAD shared object loaded!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menambahkan tanda-tanda penyusun yang diperlukan untuk mengkompilasi di bagian atas berkas sebagai komentar. Saya memperoleh tanda-tanda ini dari posting blog ini tentang penggunaan </font></font><code class="language-plaintext highlighter-rouge">LD_PRELOAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objek bersama beberapa waktu lalu: https://tbrindus.ca/correct-ld-preload-hooking-libc/.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita sekarang dapat menggunakan </font></font><code class="language-plaintext highlighter-rouge">LD_PRELOAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel lingkungan dan menjalankan objdump dengan objek bersama kita yang seharusnya dicetak saat dimuat:</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h0mbre@ubuntu:~/blogpost$ LD_PRELOAD=/home/h0mbre/blogpost/blog_harness.so objdump -D /bin/ls &gt; /tmp/output.txt &amp;&amp; head -n 20 /tmp/output.txt<font></font>
**&gt; LD_PRELOAD shared object loaded!<font></font>
<font></font>
/bin/ls:     file format elf64-x86-64<font></font>
<font></font>
<font></font>
Disassembly of section .interp:<font></font>
<font></font>
0000000000000238 &lt;.interp&gt;:<font></font>
 238:   2f                      (bad)  <font></font>
 239:   6c                      ins    BYTE PTR es:[rdi],dx<font></font>
 23a:   69 62 36 34 2f 6c 64    imul   esp,DWORD PTR [rdx+0x36],0x646c2f34<font></font>
 241:   2d 6c 69 6e 75          sub    eax,0x756e696c<font></font>
 246:   78 2d                   js     275 &lt;_init@@Base-0x34e3&gt;<font></font>
 248:   78 38                   js     282 &lt;_init@@Base-0x34d6&gt;<font></font>
 24a:   36 2d 36 34 2e 73       ss sub eax,0x732e3436<font></font>
 250:   6f                      outs   dx,DWORD PTR ds:[rsi]<font></font>
 251:   2e 32 00                xor    al,BYTE PTR cs:[rax]<font></font>
<font></font>
Disassembly of section .note.ABI-tag:<font></font>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berhasil, sekarang kita dapat mulai mencari fungsi untuk dihubungkan.</font></font></p>

<h2 id="looking-for-hooks"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mencari Kait</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahasa Indonesia: Hal pertama yang perlu kita lakukan adalah membuat nama file palsu untuk memberi objdump sehingga kita dapat mulai menguji berbagai hal. Kita akan menyalin </font></font><code class="language-plaintext highlighter-rouge">/bin/ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke direktori kerja saat ini dan menyebutnya </font></font><code class="language-plaintext highlighter-rouge">fuzzme</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini akan memungkinkan kita untuk bermain-main secara generik dengan harness untuk tujuan pengujian. Sekarang kita memiliki </font></font><code class="language-plaintext highlighter-rouge">strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">output kita, kita tahu bahwa objdump memanggil </font></font><code class="language-plaintext highlighter-rouge">stat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jalur untuk file input kita ( </font></font><code class="language-plaintext highlighter-rouge">/bin/ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) beberapa kali sebelum kita mendapatkan panggilan itu ke </font></font><code class="language-plaintext highlighter-rouge">openat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Karena kita tahu file kita belum dibuka, dan syscall menggunakan jalur untuk arg pertama, kita dapat menebak bahwa syscall ini dihasilkan dari fungsi wrapper yang diekspor libc untuk </font></font><code class="language-plaintext highlighter-rouge">stat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><code class="language-plaintext highlighter-rouge">lstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Saya akan berasumsi </font></font><code class="language-plaintext highlighter-rouge">stat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">karena kita tidak berurusan dengan tautan simbolik apa pun untuk </font></font><code class="language-plaintext highlighter-rouge">/bin/ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di kotak saya. Kita dapat menambahkan hook untuk </font></font><code class="language-plaintext highlighter-rouge">stat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menguji untuk melihat apakah kita menemukannya dan memeriksa apakah itu dipanggil untuk file input target kita (sekarang berubah menjadi </font></font><code class="language-plaintext highlighter-rouge">fuzzme</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat hook, kita akan mengikuti pola di mana kita mendefinisikan pointer ke fungsi riil melalui a </font></font><code class="language-plaintext highlighter-rouge">typedef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan kemudian kita akan menginisialisasi pointer sebagai </font></font><code class="language-plaintext highlighter-rouge">NULL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Setelah kita perlu menentukan lokasi fungsi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">riil</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang kita hook, kita dapat menggunakan </font></font><code class="language-plaintext highlighter-rouge">dlsym(RLTD_NEXT, &lt;symbol name&gt;)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mendapatkan lokasinya dan mengubah nilai pointer ke alamat simbol riil. (Ini akan lebih jelas nanti).</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita perlu mengaitkan </font></font><code class="language-plaintext highlighter-rouge">stat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang muncul sebagai </font></font><code class="language-plaintext highlighter-rouge">man 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entri </font></font><a href="https://linux.die.net/man/3/stat"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (artinya itu adalah fungsi yang diekspor libc) serta </font></font><code class="language-plaintext highlighter-rouge">man 2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entri (artinya itu adalah syscall). Ini membingungkan saya untuk waktu yang lama dan saya sering salah memahami cara kerja syscall karena desakan penamaan tabrakan ini. Anda dapat membaca salah satu blogpost penelitian pertama yang pernah saya lakukan </font></font><a href="https://h0mbre.github.io/Learn-C-By-Creating-A-Rootkit/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di mana kebingungannya nyata dan saya sering membuat klaim yang salah. (PS, saya tidak akan pernah mengedit blogpost lama yang ada kesalahannya, itu seperti kapsul waktu, dan itu keren bagi saya).</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami ingin menulis sebuah fungsi yang ketika dipanggil, cukup mencetak sesuatu dan keluar sehingga kami tahu hook kami berhasil. Untuk saat ini, kode kami terlihat seperti ini:</font></font></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 
Compiler flags: 
gcc -shared -Wall -Werror -fPIC blog_harness.c -o blog_harness.so -ldl
*/</span><font></font>
<font></font>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> /* printf */</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="c1"> /* stat */</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="c1"> /* exit */</span><span class="cp">
</span>
<span class="c1">// Filename of the input file we're trying to emulate</span>
<span class="cp">#define FUZZ_TARGET "fuzzme"
</span>
<span class="c1">// Declare a prototype for the real stat as a function pointer</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">stat_t</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">);</span>
<span class="n">stat_t</span> <span class="n">real_stat</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
<span class="c1">// Hook function, objdump will call this stat instead of the real one</span>
<span class="kt">int</span> <span class="nf">stat</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"** stat() hook!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Routine to be called when our shared object is loaded</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">_hook_load</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"** LD_PRELOAD shared object loaded!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, jika kita mengompilasi dan menjalankannya, kita tidak pernah mencetak dan keluar sehingga hook kita tidak dipanggil. Ada yang salah. Terkadang, fungsi terkait file di libc memiliki </font></font><code class="language-plaintext highlighter-rouge">64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">varian, seperti </font></font><code class="language-plaintext highlighter-rouge">open()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code class="language-plaintext highlighter-rouge">open64()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang digunakan secara bergantian tergantung pada konfigurasi dan flag. Saya mencoba mengaitkan a </font></font><code class="language-plaintext highlighter-rouge">stat64()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tetapi masih belum berhasil mencapai hook.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untungnya, saya bukan orang pertama yang mengalami masalah ini, ada </font></font><a href="https://stackoverflow.com/questions/5478780/c-and-ld-preload-open-and-open64-calls-intercepted-but-not-stat64"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jawaban yang bagus di Stackoverflow tentang masalah yang sama</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang menjelaskan bagaimana libc tidak benar-benar mengekspor </font></font><code class="language-plaintext highlighter-rouge">stat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan cara yang sama seperti yang dilakukan untuk fungsi lain seperti </font></font><code class="language-plaintext highlighter-rouge">open()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code class="language-plaintext highlighter-rouge">open64()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sebaliknya ia mengekspor simbol yang disebut </font></font><code class="language-plaintext highlighter-rouge">__xstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang memiliki tanda tangan yang sedikit berbeda dan memerlukan argumen baru yang disebut </font></font><code class="language-plaintext highlighter-rouge">version</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang dimaksudkan untuk menjelaskan versi </font></font><code class="language-plaintext highlighter-rouge">stat struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pemanggil mana yang diharapkan. Ini seharusnya terjadi secara ajaib di balik layar, tetapi di situlah kita hidup sekarang, jadi kita harus membuat keajaiban itu terjadi sendiri. Aturan yang sama berlaku untuk </font></font><code class="language-plaintext highlighter-rouge">lstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code class="language-plaintext highlighter-rouge">fstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juga, mereka memiliki </font></font><code class="language-plaintext highlighter-rouge">__lxstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code class="language-plaintext highlighter-rouge">__fxstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masing-masing.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menemukan definisi untuk fungsi-fungsi </font></font><a href="https://refspecs.linuxfoundation.org/LSB_1.1.0/gLSB/baselib-xstat-1.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jadi kita dapat menambahkan </font></font><code class="language-plaintext highlighter-rouge">__xstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaitan ke objek bersama kita sebagai pengganti </font></font><code class="language-plaintext highlighter-rouge">stat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan melihat apakah keberuntungan kita berubah. Kode kita sekarang terlihat seperti ini:</font></font></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 
Compiler flags: 
gcc -shared -Wall -Werror -fPIC blog_harness.c -o blog_harness.so -ldl
*/</span><font></font>
<font></font>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> /* printf */</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="c1"> /* stat */</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="c1"> /* exit */</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="c1"> /* __xstat, __fxstat */</span><span class="cp">
</span>
<span class="c1">// Filename of the input file we're trying to emulate</span>
<span class="cp">#define FUZZ_TARGET "fuzzme"
</span>
<span class="c1">// Declare a prototype for the real stat as a function pointer</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">__xstat_t</span><span class="p">)(</span><span class="kt">int</span> <span class="n">__ver</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__filename</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">__stat_buf</span><span class="p">);</span>
<span class="n">__xstat_t</span> <span class="n">real_xstat</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
<span class="c1">// Hook function, objdump will call this stat instead of the real one</span>
<span class="kt">int</span> <span class="nf">__xstat</span><span class="p">(</span><span class="kt">int</span> <span class="n">__ver</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__filename</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">__stat_buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"** Hit our __xstat() hook!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Routine to be called when our shared object is loaded</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">_hook_load</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"** LD_PRELOAD shared object loaded!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang jika kita menjalankan objek bersama kita, kita mendapatkan hasil yang diinginkan, di suatu tempat, hook kita berhasil. Sekarang kita dapat membantu diri kita sendiri sedikit dan mencetak nama file yang diminta oleh hook dan kemudian benar-benar memanggil real </font></font><code class="language-plaintext highlighter-rouge">__xstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atas nama pemanggil. Sekarang ketika hook kita berhasil, kita harus menyelesaikan lokasi real </font></font><code class="language-plaintext highlighter-rouge">__xstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berdasarkan nama, jadi kita akan menambahkan fungsi penyelesaian simbol ke objek bersama kita. Kode objek bersama kita sekarang terlihat seperti ini:</font></font></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 
Compiler flags: 
gcc -shared -Wall -Werror -fPIC blog_harness.c -o blog_harness.so -ldl
*/</span><font></font>
<font></font>
<span class="cp">#define _GNU_SOURCE     </span><span class="cm">/* dlsym */</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> /* printf */</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="c1"> /* stat */</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="c1"> /* exit */</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="c1"> /* __xstat, __fxstat */</span><span class="cp">
#include</span> <span class="cpf">&lt;dlfcn.h&gt;</span><span class="c1"> /* dlsym and friends */</span><span class="cp">
</span>
<span class="c1">// Filename of the input file we're trying to emulate</span>
<span class="cp">#define FUZZ_TARGET "fuzzme"
</span>
<span class="c1">// Declare a prototype for the real stat as a function pointer</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">__xstat_t</span><span class="p">)(</span><span class="kt">int</span> <span class="n">__ver</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__filename</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">__stat_buf</span><span class="p">);</span>
<span class="n">__xstat_t</span> <span class="n">real_xstat</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
<span class="c1">// Returns memory address of *next* location of symbol in library search order</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">_resolve_symbol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symbol</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Clear previous errors</span>
    <span class="n">dlerror</span><span class="p">();</span><font></font>
<font></font>
    <span class="c1">// Get symbol address</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="n">symbol</span><span class="p">);</span><font></font>
<font></font>
    <span class="c1">// Check for error</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">dlerror</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Err resolving '%s' addr: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><font></font>
    <font></font>
    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Hook function, objdump will call this stat instead of the real one</span>
<span class="kt">int</span> <span class="nf">__xstat</span><span class="p">(</span><span class="kt">int</span> <span class="n">__ver</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__filename</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">__stat_buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Print the filename requested</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"** __xstat() hook called for filename: '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__filename</span><span class="p">);</span><font></font>
<font></font>
    <span class="c1">// Resolve the address of the real __xstat() on demand and only once</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">real_xstat</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">real_xstat</span> <span class="o">=</span> <span class="n">_resolve_symbol</span><span class="p">(</span><span class="s">"__xstat"</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Call the real __xstat() for the caller so everything keeps going</span>
    <span class="k">return</span> <span class="n">real_xstat</span><span class="p">(</span><span class="n">__ver</span><span class="p">,</span> <span class="n">__filename</span><span class="p">,</span> <span class="n">__stat_buf</span><span class="p">);</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Routine to be called when our shared object is loaded</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">_hook_load</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"** LD_PRELOAD shared object loaded!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baiklah, jadi sekarang ketika kita menjalankan ini, dan kita memeriksa pernyataan cetak, segalanya menjadi sedikit rumit.</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h0mbre@ubuntu:~/blogpost$ LD_PRELOAD=/home/h0mbre/blogpost/blog_harness.so objdump -D fuzzme &gt; /tmp/output.txt &amp;&amp; grep "** __xstat" /tmp/output.txt<font></font>
** __xstat() hook called for filename: 'fuzzme'<font></font>
** __xstat() hook called for filename: 'fuzzme'<font></font>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi sekarang kita bisa bersenang-senang.</font></font></p>

<h2 id="__xstat-hook"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kait __xstat()</font></font></h2>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi tujuan dari kait ini adalah untuk menipu objdump dan membuatnya mengira bahwa ia berhasil menjadi </font></font><code class="language-plaintext highlighter-rouge">stat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berkas masukan. Ingat, kita membuat snapshot fuzzing harness sehingga tujuan kita adalah untuk terus-menerus membuat masukan baru dan memasukkannya ke objdump melalui harness ini. Yang terpenting, harness kita harus mampu merepresentasikan masukan dengan panjang variabel (yang akan disimpan murni dalam memori) sebagai berkas. Setiap fuzzcase, panjang berkas dapat berubah dan harness kita harus mengakomodasi hal itu.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ide saya saat ini adalah membuat sesuatu yang agak "sah" </font></font><code class="language-plaintext highlighter-rouge">stat struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang biasanya akan dikembalikan untuk berkas kita yang sebenarnya </font></font><code class="language-plaintext highlighter-rouge">fuzzme</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang hanya merupakan salinan dari </font></font><code class="language-plaintext highlighter-rouge">/bin/ls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kita dapat menyimpan ini </font></font><code class="language-plaintext highlighter-rouge">stat struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secara global dan hanya memperbarui bidang ukuran saat setiap kasus fuzz baru muncul. Jadi garis waktu alur kerja fuzzing snapshot kita akan terlihat seperti ini:</font></font></p>
<ol>
  <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi kami </font></font><code class="language-plaintext highlighter-rouge">constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dipanggil saat objek bersama kami dimuat</font></font></li>
  <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami </font></font><code class="language-plaintext highlighter-rouge">constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyiapkan “sah” global </font></font><code class="language-plaintext highlighter-rouge">stat struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang dapat kami perbarui untuk setiap fuzzcase dan meneruskannya kembali ke pemanggil yang </font></font><code class="language-plaintext highlighter-rouge">__xstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mencoba mencapai </font></font><code class="language-plaintext highlighter-rouge">stat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">target fuzzing kami</font></font></li>
  <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuzzer imajiner menjalankan objdump ke lokasi snapshot</font></font></li>
  <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hook kami </font></font><code class="language-plaintext highlighter-rouge">__xstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memperbarui bidang ukuran “sah” global </font></font><code class="language-plaintext highlighter-rouge">stat struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menyalinnya </font></font><code class="language-plaintext highlighter-rouge">stat struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke buffer pemanggil</font></font></li>
  <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuzzer imajiner mengembalikan status objdump ke statusnya pada waktu snapshot</font></font></li>
  <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuzzer imajiner menyalin input baru ke dalam harness dan memperbarui ukuran input</font></font></li>
  <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kait kita </font></font><code class="language-plaintext highlighter-rouge">__xstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dipanggil sekali lagi, dan kita ulangi langkah 4, proses ini terjadi terus menerus tanpa henti.</font></font></li>
</ol>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi kami membayangkan fuzzer memiliki beberapa rutinitas seperti ini dalam pseudocode, meskipun itu mungkin lintas proses dan memerlukan </font></font><code class="language-plaintext highlighter-rouge">process_vm_writev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>insert_fuzzcase(config.input_location, config.input_size_location, input, input_size) {<font></font>
  memcpy(config.input_location, &amp;input, input_size);<font></font>
  memcpy(config.input_size_location, &amp;input_size, sizeof(size_t));<font></font>
}<font></font>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu hal penting yang perlu diingat adalah jika fuzzer snapshot memulihkan objdump ke status snapshot-nya setiap iterasi fuzzing, kita harus berhati-hati untuk tidak bergantung pada memori global yang dapat diubah. Memori global </font></font><code class="language-plaintext highlighter-rouge">stat struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan aman karena akan dibuat selama </font></font><code class="language-plaintext highlighter-rouge">constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">namun, bidang ukurannya akan dikembalikan ke nilai aslinya setiap iterasi fuzzing oleh rutinitas pemulihan snapshot fuzzer.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita juga memerlukan alamat global yang dapat dikenali untuk menyimpan data global yang dapat berubah seperti ukuran input saat ini. Beberapa fuzzer snapshot memiliki fleksibilitas untuk mengabaikan rentang memori yang berdekatan untuk tujuan pemulihan. Jadi, jika kita dapat membuat beberapa buffer yang berdekatan dalam memori pada alamat yang dapat dikenali, kita dapat membuat fuzzer imajiner kita mengabaikan rentang tersebut untuk pemulihan snapshot. Jadi, kita perlu memiliki tempat untuk menyimpan input, serta informasi tentang ukurannya. Kita kemudian akan memberi tahu fuzzer tentang lokasi ini dan ketika ia menghasilkan input baru, ia akan menyalinnya ke lokasi input dan kemudian memperbarui informasi ukuran input saat ini.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi sekarang konstruktor kita memiliki tugas tambahan: mengatur lokasi input serta informasi ukuran input. Kita dapat melakukannya dengan mudah dengan panggilan yang </font></font><code class="language-plaintext highlighter-rouge">mmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan memungkinkan kita menentukan alamat yang kita inginkan untuk memetakan pemetaan kita dengan </font></font><code class="language-plaintext highlighter-rouge">MAP_FIXED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bendera. Kita juga akan membuat </font></font><code class="language-plaintext highlighter-rouge">MAX_INPUT_SZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definisi sehingga kita tahu berapa banyak memori yang akan dipetakan dari lokasi input.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara terpisah, fungsi yang terkait dengan pemetaan ruang memori untuk input itu sendiri dan informasi ukurannya tampak seperti ini. Perhatikan bahwa kami menggunakan </font></font><code class="language-plaintext highlighter-rouge">MAP_FIXED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan kami memeriksa alamat yang dikembalikan </font></font><code class="language-plaintext highlighter-rouge">mmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya untuk memastikan panggilan tidak berhasil tetapi memetakan memori kami di lokasi yang berbeda:</font></font></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Map memory to hold our inputs in memory and information about their size</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_create_mem_mappings</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
    <span class="c1">// Map the page to hold the input size</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
        <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">INPUT_SZ_ADDR</span><span class="p">),</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">),</span>
        <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
        <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_FIXED</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">MAP_FAILED</span> <span class="o">==</span> <span class="n">result</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Err mapping INPUT_SZ_ADDR, mapped @ %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Let's actually initialize the value at the input size location as well</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><font></font>
<font></font>
    <span class="c1">// Map the pages to hold the input contents</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
        <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">INPUT_ADDR</span><span class="p">),</span>
        <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">MAX_INPUT_SZ</span><span class="p">),</span>
        <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
        <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_FIXED</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">MAP_FAILED</span> <span class="o">==</span> <span class="n">result</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_ADDR</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Err mapping INPUT_ADDR, mapped @ %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Init the value</span>
    <span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_ADDR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">MAX_INPUT_SZ</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">mmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan memetakan kelipatan dari ukuran halaman apa pun yang ada di sistem Anda (biasanya 4096 byte). Jadi, ketika kami meminta </font></font><code class="language-plaintext highlighter-rouge">sizeof(size_t)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">byte untuk pemetaan, </font></font><code class="language-plaintext highlighter-rouge">mmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seperti: "Hmm, itu hanya satu halaman, kawan" dan mengembalikan satu halaman penuh dari </font></font><code class="language-plaintext highlighter-rouge">0x1336000 - 0x1337000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang tidak inklusif di bagian atas.</font></font></p>

<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan sampingan acak, berhati-hatilah dengan aritmatika dalam definisi dan makro seperti yang telah saya lakukan di sini dengan </font></font><code class="language-plaintext highlighter-rouge">MAX_INPUT_SIZE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sangat mudah bagi pra-prosesor untuk mengganti teks Anda dengan kata kunci definisi dan merusak beberapa urutan operasi atau bahkan melimpahkan tipe primitif tertentu seperti </font></font><code class="language-plaintext highlighter-rouge">int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></strong></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahasa Indonesia: Sekarang setelah kita menyiapkan memori untuk fuzzer untuk menyimpan input dan informasi tentang ukuran input, kita dapat membuat struct stat global itu. Namun, kita sebenarnya punya masalah besar. Bagaimana kita dapat memanggil into </font></font><code class="language-plaintext highlighter-rouge">__xstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mendapatkan "legit" kita </font></font><code class="language-plaintext highlighter-rouge">stat struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jika kita telah </font></font><code class="language-plaintext highlighter-rouge">__xstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melakukan hook? Kita akan melakukan hook kita sendiri. Untuk menghindari ini, kita dapat memanggil </font></font><code class="language-plaintext highlighter-rouge">__xstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan argumen khusus </font></font><code class="language-plaintext highlighter-rouge">__ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang kita tahu akan berarti bahwa itu dipanggil dari </font></font><code class="language-plaintext highlighter-rouge">constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, variabelnya adalah </font></font><code class="language-plaintext highlighter-rouge">int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jadi mari kita gunakan </font></font><code class="language-plaintext highlighter-rouge">0x1337</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai nilai khusus. Dengan begitu, dalam hook kita, jika kita memeriksa </font></font><code class="language-plaintext highlighter-rouge">__ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan itu </font></font><code class="language-plaintext highlighter-rouge">0x1337</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kita tahu kita dipanggil dari </font></font><code class="language-plaintext highlighter-rouge">constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan kita benar-benar dapat stat file asli kita dan membuat "legit" global </font></font><code class="language-plaintext highlighter-rouge">stat struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ketika saya membuang panggilan normal oleh objdump ke </font></font><code class="language-plaintext highlighter-rouge">__xstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selalu </font></font><code class="language-plaintext highlighter-rouge">__version</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berupa nilai </font></font><code class="language-plaintext highlighter-rouge">1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jadi kita akan menambalnya kembali ke itu di dalam hook kita. Sekarang seluruh file sumber objek bersama kita akan terlihat seperti ini:</font></font></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 
Compiler flags: 
gcc -shared -Wall -Werror -fPIC blog_harness.c -o blog_harness.so -ldl
*/</span><font></font>
<font></font>
<span class="cp">#define _GNU_SOURCE     </span><span class="cm">/* dlsym */</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> /* printf */</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="c1"> /* stat */</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="c1"> /* exit */</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="c1"> /* __xstat, __fxstat */</span><span class="cp">
#include</span> <span class="cpf">&lt;dlfcn.h&gt;</span><span class="c1"> /* dlsym and friends */</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="c1"> /* mmap */</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="c1"> /* memset */</span><span class="cp">
</span>
<span class="c1">// Filename of the input file we're trying to emulate</span>
<span class="cp">#define FUZZ_TARGET "fuzzme"
</span>
<span class="c1">// Definitions for our in-memory inputs </span>
<span class="cp">#define INPUT_SZ_ADDR   0x1336000
#define INPUT_ADDR      0x1337000
#define MAX_INPUT_SZ    (1024 * 1024)
</span>
<span class="c1">// Our "legit" global stat struct</span>
<span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span><font></font>
<font></font>
<span class="c1">// Declare a prototype for the real stat as a function pointer</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">__xstat_t</span><span class="p">)(</span><span class="kt">int</span> <span class="n">__ver</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__filename</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">__stat_buf</span><span class="p">);</span>
<span class="n">__xstat_t</span> <span class="n">real_xstat</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
<span class="c1">// Returns memory address of *next* location of symbol in library search order</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">_resolve_symbol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symbol</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Clear previous errors</span>
    <span class="n">dlerror</span><span class="p">();</span><font></font>
<font></font>
    <span class="c1">// Get symbol address</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="n">symbol</span><span class="p">);</span><font></font>
<font></font>
    <span class="c1">// Check for error</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">dlerror</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Err resolving '%s' addr: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><font></font>
    <font></font>
    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Hook for __xstat </span>
<span class="kt">int</span> <span class="nf">__xstat</span><span class="p">(</span><span class="kt">int</span> <span class="n">__ver</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">__filename</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span><span class="o">*</span> <span class="n">__stat_buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Resolve the real __xstat() on demand and maybe multiple times!</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">real_xstat</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">real_xstat</span> <span class="o">=</span> <span class="n">_resolve_symbol</span><span class="p">(</span><span class="s">"__xstat"</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Assume the worst, always</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><font></font>
<font></font>
    <span class="c1">// Special __ver value check to see if we're calling from constructor</span>
    <span class="k">if</span> <span class="p">(</span><span class="mh">0x1337</span> <span class="o">==</span> <span class="n">__ver</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Patch back up the version value before sending to real xstat</span>
        <span class="n">__ver</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><font></font>
<font></font>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">real_xstat</span><span class="p">(</span><span class="n">__ver</span><span class="p">,</span> <span class="n">__filename</span><span class="p">,</span> <span class="n">__stat_buf</span><span class="p">);</span><font></font>
<font></font>
        <span class="c1">// Set the real_xstat back to NULL</span>
        <span class="n">real_xstat</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Determine if we're stat'ing our fuzzing target</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">__filename</span><span class="p">,</span> <span class="n">FUZZ_TARGET</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// Update our global stat struct</span>
        <span class="n">st</span><span class="p">.</span><span class="n">st_size</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span><span class="p">;</span><font></font>
<font></font>
        <span class="c1">// Send it back to the caller, skip syscall</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">__stat_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">stat</span><span class="p">));</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Just a normal stat, send to real xstat</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">real_xstat</span><span class="p">(</span><span class="n">__ver</span><span class="p">,</span> <span class="n">__filename</span><span class="p">,</span> <span class="n">__stat_buf</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Map memory to hold our inputs in memory and information about their size</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_create_mem_mappings</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
    <span class="c1">// Map the page to hold the input size</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
        <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">INPUT_SZ_ADDR</span><span class="p">),</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">),</span>
        <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
        <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_FIXED</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">MAP_FAILED</span> <span class="o">==</span> <span class="n">result</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Err mapping INPUT_SZ_ADDR, mapped @ %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Let's actually initialize the value at the input size location as well</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><font></font>
<font></font>
    <span class="c1">// Map the pages to hold the input contents</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
        <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">INPUT_ADDR</span><span class="p">),</span>
        <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">MAX_INPUT_SZ</span><span class="p">),</span>
        <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
        <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_FIXED</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">MAP_FAILED</span> <span class="o">==</span> <span class="n">result</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_ADDR</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Err mapping INPUT_ADDR, mapped @ %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Init the value</span>
    <span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_ADDR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">MAX_INPUT_SZ</span><span class="p">);</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Routine to be called when our shared object is loaded</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">_hook_load</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Create memory mappings to hold our input and information about its size</span>
    <span class="n">_create_mem_mappings</span><span class="p">();</span>    
<span class="p">}</span>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang jika kita menjalankan ini, kita mendapatkan output berikut:</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h0mbre@ubuntu:~/blogpost$ LD_PRELOAD=/home/h0mbre/blogpost/blog_harness.so objdump -D fuzzme<font></font>
objdump: Warning: 'fuzzme' is not an ordinary file<font></font>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keren sekali, ini berarti pengembang objdump melakukan sesuatu yang benar dan mereka </font></font><code class="language-plaintext highlighter-rouge">stat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan berkata: "Hei, file ini panjangnya nol byte, ada yang aneh" dan mereka mengeluarkan pesan kesalahan ini dan keluar. Kerja bagus, pengembang!</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, kami telah mengidentifikasi masalah, kami perlu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mensimulasikan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fuzzer yang menempatkan input nyata ke dalam memori. Untuk melakukannya, saya akan mulai menggunakan </font></font><code class="language-plaintext highlighter-rouge">#ifdef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menentukan apakah kami menguji objek bersama kami atau tidak. Jadi pada dasarnya, jika kami mengompilasi objek bersama dan mendefinisikan </font></font><code class="language-plaintext highlighter-rouge">TEST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, objek bersama kami akan menyalin "input" ke dalam memori untuk mensimulasikan bagaimana fuzzer akan berperilaku selama fuzzing dan kami dapat melihat apakah harness kami bekerja dengan tepat. Jadi, jika kami mendefinisikan </font></font><code class="language-plaintext highlighter-rouge">TEST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kami akan menyalin </font></font><code class="language-plaintext highlighter-rouge">/bin/ed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke dalam memori, dan kami akan memperbarui anggota ukuran "sah" global kami </font></font><code class="language-plaintext highlighter-rouge">stat struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan menempatkan </font></font><code class="language-plaintext highlighter-rouge">/bin/ed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">byte ke dalam memori.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat mengompilasi objek bersama sekarang untuk melakukan pengujian sebagai berikut:</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc -D TEST -shared -Wall -Werror -fPIC blog_harness.c -o blog_harness.so -ld
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita juga perlu menyiapkan "legit" global kita </font></font><code class="language-plaintext highlighter-rouge">stat struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kode untuk melakukannya akan terlihat seperti berikut. Ingat, kita memberikan </font></font><code class="language-plaintext highlighter-rouge">__ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel palsu untuk memberi </font></font><code class="language-plaintext highlighter-rouge">__xstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tahu hook bahwa kitalah yang ada dalam </font></font><code class="language-plaintext highlighter-rouge">constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rutin, yang memungkinkan hook berperilaku baik dan memberi kita apa yang </font></font><code class="language-plaintext highlighter-rouge">stat struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita butuhkan:</font></font></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create a "legit" stat struct globally to pass to callers</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_setup_stat_struct</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Create a global stat struct for our file in case someone asks, this way</span>
    <span class="c1">// when someone calls stat() or fstat() on our target, we can just return the</span>
    <span class="c1">// slightly altered (new size) stat struct &amp;skip the kernel, save syscalls</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">__xstat</span><span class="p">(</span><span class="mh">0x1337</span><span class="p">,</span> <span class="n">FUZZ_TARGET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Error creating stat struct for '%s' during load</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">FUZZ_TARGET</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara keseluruhan, seluruh harness kita sekarang terlihat seperti ini:</font></font></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 
Compiler flags: 
gcc -shared -Wall -Werror -fPIC blog_harness.c -o blog_harness.so -ldl
*/</span><font></font>
<font></font>
<span class="cp">#define _GNU_SOURCE     </span><span class="cm">/* dlsym */</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> /* printf */</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="c1"> /* stat */</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="c1"> /* exit */</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="c1"> /* __xstat, __fxstat */</span><span class="cp">
#include</span> <span class="cpf">&lt;dlfcn.h&gt;</span><span class="c1"> /* dlsym and friends */</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="c1"> /* mmap */</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="c1"> /* memset */</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="c1"> /* open */</span><span class="cp">
</span>
<span class="c1">// Filename of the input file we're trying to emulate</span>
<span class="cp">#define FUZZ_TARGET     "fuzzme"
</span>
<span class="c1">// Definitions for our in-memory inputs </span>
<span class="cp">#define INPUT_SZ_ADDR   0x1336000
#define INPUT_ADDR      0x1337000
#define MAX_INPUT_SZ    (1024 * 1024)
</span>
<span class="c1">// For testing purposes, we read /bin/ed into our input buffer to simulate</span>
<span class="c1">// what the fuzzer would do</span>
<span class="cp">#define  TEST_FILE      "/bin/ed"
</span>
<span class="c1">// Our "legit" global stat struct</span>
<span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span><font></font>
<font></font>
<span class="c1">// Declare a prototype for the real stat as a function pointer</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">__xstat_t</span><span class="p">)(</span><span class="kt">int</span> <span class="n">__ver</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__filename</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">__stat_buf</span><span class="p">);</span>
<span class="n">__xstat_t</span> <span class="n">real_xstat</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
<span class="c1">// Returns memory address of *next* location of symbol in library search order</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">_resolve_symbol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symbol</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Clear previous errors</span>
    <span class="n">dlerror</span><span class="p">();</span><font></font>
<font></font>
    <span class="c1">// Get symbol address</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="n">symbol</span><span class="p">);</span><font></font>
<font></font>
    <span class="c1">// Check for error</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">dlerror</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Err resolving '%s' addr: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><font></font>
    <font></font>
    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Hook for __xstat </span>
<span class="kt">int</span> <span class="nf">__xstat</span><span class="p">(</span><span class="kt">int</span> <span class="n">__ver</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">__filename</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span><span class="o">*</span> <span class="n">__stat_buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Resolve the real __xstat() on demand and maybe multiple times!</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">real_xstat</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">real_xstat</span> <span class="o">=</span> <span class="n">_resolve_symbol</span><span class="p">(</span><span class="s">"__xstat"</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Assume the worst, always</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><font></font>
<font></font>
    <span class="c1">// Special __ver value check to see if we're calling from constructor</span>
    <span class="k">if</span> <span class="p">(</span><span class="mh">0x1337</span> <span class="o">==</span> <span class="n">__ver</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Patch back up the version value before sending to real xstat</span>
        <span class="n">__ver</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><font></font>
<font></font>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">real_xstat</span><span class="p">(</span><span class="n">__ver</span><span class="p">,</span> <span class="n">__filename</span><span class="p">,</span> <span class="n">__stat_buf</span><span class="p">);</span><font></font>
<font></font>
        <span class="c1">// Set the real_xstat back to NULL</span>
        <span class="n">real_xstat</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Determine if we're stat'ing our fuzzing target</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">__filename</span><span class="p">,</span> <span class="n">FUZZ_TARGET</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// Update our global stat struct</span>
        <span class="n">st</span><span class="p">.</span><span class="n">st_size</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span><span class="p">;</span><font></font>
<font></font>
        <span class="c1">// Send it back to the caller, skip syscall</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">__stat_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">stat</span><span class="p">));</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Just a normal stat, send to real xstat</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">real_xstat</span><span class="p">(</span><span class="n">__ver</span><span class="p">,</span> <span class="n">__filename</span><span class="p">,</span> <span class="n">__stat_buf</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Map memory to hold our inputs in memory and information about their size</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_create_mem_mappings</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
    <span class="c1">// Map the page to hold the input size</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
        <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">INPUT_SZ_ADDR</span><span class="p">),</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">),</span>
        <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
        <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_FIXED</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">MAP_FAILED</span> <span class="o">==</span> <span class="n">result</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Err mapping INPUT_SZ_ADDR, mapped @ %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Let's actually initialize the value at the input size location as well</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><font></font>
<font></font>
    <span class="c1">// Map the pages to hold the input contents</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
        <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">INPUT_ADDR</span><span class="p">),</span>
        <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">MAX_INPUT_SZ</span><span class="p">),</span>
        <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
        <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_FIXED</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">MAP_FAILED</span> <span class="o">==</span> <span class="n">result</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_ADDR</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Err mapping INPUT_ADDR, mapped @ %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Init the value</span>
    <span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_ADDR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">MAX_INPUT_SZ</span><span class="p">);</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Create a "legit" stat struct globally to pass to callers</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_setup_stat_struct</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">__xstat</span><span class="p">(</span><span class="mh">0x1337</span><span class="p">,</span> <span class="n">FUZZ_TARGET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Error creating stat struct for '%s' during load</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">FUZZ_TARGET</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Used for testing, load /bin/ed into the input buffer and update its size info</span>
<span class="cp">#ifdef TEST
</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">_test_func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>    
    <span class="c1">// Open TEST_FILE for reading</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">TEST_FILE</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to open '%s' during test</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">TEST_FILE</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Attempt to read max input buf size</span>
    <span class="kt">ssize_t</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">INPUT_ADDR</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">MAX_INPUT_SZ</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span><font></font>
<font></font>
    <span class="c1">// Update the input size</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">bytes</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif
</span>
<span class="c1">// Routine to be called when our shared object is loaded</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">_hook_load</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Create memory mappings to hold our input and information about its size</span>
    <span class="n">_create_mem_mappings</span><span class="p">();</span><font></font>
<font></font>
    <span class="c1">// Setup global "legit" stat struct</span>
    <span class="n">_setup_stat_struct</span><span class="p">();</span><font></font>
<font></font>
    <span class="c1">// If we're testing, load /bin/ed up into our input buffer and update size</span>
<span class="cp">#ifdef TEST
</span>    <span class="n">_test_func</span><span class="p">();</span>
<span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang jika kita menjalankannya di bawah </font></font><code class="language-plaintext highlighter-rouge">strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kita melihat bahwa kedua </font></font><code class="language-plaintext highlighter-rouge">stat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panggilan kita hilang secara mencolok.</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>close(3)                                = 0<font></font>
openat(AT_FDCWD, "fuzzme", O_RDONLY)    = 3<font></font>
fcntl(3, F_GETFD)                       = 0<font></font>
fcntl(3, F_SETFD, FD_CLOEXEC)           = 0<font></font>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita tidak lagi melihat </font></font><code class="language-plaintext highlighter-rouge">stat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panggilan sebelum </font></font><code class="language-plaintext highlighter-rouge">openat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan program tidak rusak secara signifikan. Jadi kait ini tampaknya berfungsi dengan baik. Sekarang kita perlu menangani </font></font><code class="language-plaintext highlighter-rouge">openat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan memastikan kita tidak benar-benar berinteraksi dengan berkas masukan kita, tetapi sebaliknya mengelabui objdump untuk berinteraksi dengan masukan kita di memori.</font></font></p>

<h2 id="finding-a-way-to-hook-openat"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menemukan Cara untuk Mengaitkan</font></font><code class="language-plaintext highlighter-rouge">openat()</code></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intuisi saya yang bukan ahli memberi tahu saya bahwa mungkin ada beberapa cara di mana fungsi libc dapat berakhir dengan memanggil fungsi </font></font><code class="language-plaintext highlighter-rouge">openat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di balik layar. Cara-cara tersebut mungkin termasuk pembungkus </font></font><code class="language-plaintext highlighter-rouge">open()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan juga </font></font><code class="language-plaintext highlighter-rouge">fopen()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kita juga perlu memperhatikan </font></font><code class="language-plaintext highlighter-rouge">64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">varian-variannya ( </font></font><code class="language-plaintext highlighter-rouge">open64()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code class="language-plaintext highlighter-rouge">fopen64()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Saya memutuskan untuk mencoba </font></font><code class="language-plaintext highlighter-rouge">fopen()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaitan terlebih dahulu:</font></font></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Declare prototype for the real fopen and its friend fopen64 </span>
<span class="k">typedef</span> <span class="kt">FILE</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">fopen_t</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span><span class="p">);</span>
<span class="n">fopen_t</span> <span class="n">real_fopen</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
<span class="k">typedef</span> <span class="kt">FILE</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">fopen64_t</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span><span class="p">);</span>
<span class="n">fopen64_t</span> <span class="n">real_fopen64</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
<span class="p">...</span><font></font>
<font></font>
<span class="c1">// Exploratory hooks to see if we're using fopen() related functions to open</span>
<span class="c1">// our input file</span>
<span class="kt">FILE</span><span class="o">*</span> <span class="nf">fopen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"** fopen() called for '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pathname</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span><font></font>
<font></font>
<span class="kt">FILE</span><span class="o">*</span> <span class="nf">fopen64</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"** fopen64() called for '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pathname</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita mengompilasi dan menjalankan kait eksplorasi kita, kita mendapatkan keluaran berikut:</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h0mbre@ubuntu:~/blogpost$ LD_PRELOAD=/home/h0mbre/blogpost/blog_harness.so objdump -D fuzzme<font></font>
** fopen64() called for 'fuzzme'<font></font>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bingo, DNA dino.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi sekarang kita dapat menyempurnakan fungsi kait itu sedikit agar berfungsi sesuai keinginan kita.</font></font></p>

<h2 id="refining-an-fopen64-hook"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menyempurnakan Sebuah </font></font><code class="language-plaintext highlighter-rouge">fopen64()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kait</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definisi untuk </font></font><code class="language-plaintext highlighter-rouge">fopen64()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah: ` FILE *fopen(const char *restrict pathname, const char *restrict mode); </font></font><code class="language-plaintext highlighter-rouge">. The returned </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FILE * </font></font><code class="language-plaintext highlighter-rouge"> poses a slight problem to us because this is an opaque data structure that is not meant to be understood by the caller. Which is to say, the caller is not meant to access any members of this data structure or worry about its layout in any way. You're just supposed to use the returned </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FILE * </font></font><code class="language-plaintext highlighter-rouge"> as an object to pass to other functions, such as </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fclose()`. Sistem menangani struktur data di sana dalam jenis fungsi terkait tersebut sehingga programmer tidak perlu khawatir tentang implementasi tertentu.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita tidak benar-benar tahu bagaimana hasil yang dikembalikan </font></font><code class="language-plaintext highlighter-rouge">FILE *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan digunakan, mungkin tidak digunakan sama sekali, atau mungkin diteruskan ke suatu fungsi sehingga </font></font><code class="language-plaintext highlighter-rouge">fread()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita memerlukan suatu cara untuk mengembalikan </font></font><code class="language-plaintext highlighter-rouge">FILE *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">struktur data yang meyakinkan kepada pemanggil yang sebenarnya dibangun dari masukan kita dalam memori dan BUKAN dari berkas masukan. Untungnya, ada suatu fungsi libc yang disebut </font></font><code class="language-plaintext highlighter-rouge">fmemopen()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang berperilaku sangat mirip dengan </font></font><code class="language-plaintext highlighter-rouge">fopen()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan juga mengembalikan </font></font><code class="language-plaintext highlighter-rouge">FILE *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jadi kita dapat melanjutkan dan membuat </font></font><code class="language-plaintext highlighter-rouge">FILE *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mengembalikan kepada pemanggil </font></font><code class="language-plaintext highlighter-rouge">fopen64()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan </font></font><code class="language-plaintext highlighter-rouge">fuzzme</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berkas masukan target. Salam hormat kepada @domenuk karena telah menunjukkan kepada saya </font></font><code class="language-plaintext highlighter-rouge">fmemopen()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, saya belum pernah menemukannya sebelumnya.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, ada satu perbedaan utama. Objdump </font></font><code class="language-plaintext highlighter-rouge">fopen()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebenarnya akan memperoleh deskriptor file untuk file yang mendasarinya dan </font></font><code class="language-plaintext highlighter-rouge">fmemopen()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena tidak benar-benar membuka file, tidak akan melakukannya. Jadi di suatu tempat dalam </font></font><code class="language-plaintext highlighter-rouge">FILE *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">struktur data, ada deskriptor file untuk file yang mendasarinya jika dikembalikan dari </font></font><code class="language-plaintext highlighter-rouge">fopen()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan tidak ada jika dikembalikan dari </font></font><code class="language-plaintext highlighter-rouge">fmemopen()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini sangat penting karena fungsi seperti </font></font><code class="language-plaintext highlighter-rouge">int fileno(FILE *stream)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat mengurai a </font></font><code class="language-plaintext highlighter-rouge">FILE *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mengembalikan deskriptor file yang mendasarinya ke pemanggil. Objdump mungkin ingin melakukan ini karena suatu alasan dan kita harus dapat menanganinya dengan kuat. Jadi kita perlu cara untuk mengetahui apakah seseorang mencoba menggunakan </font></font><code class="language-plaintext highlighter-rouge">FILE *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deskriptor file dasar palsu kita.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ide saya untuk ini adalah dengan menemukan anggota struct yang berisi deskriptor file dalam bentuk </font></font><code class="language-plaintext highlighter-rouge">FILE *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang dikembalikan </font></font><code class="language-plaintext highlighter-rouge">fmemopen()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mengubahnya menjadi sesuatu yang konyol seperti </font></font><code class="language-plaintext highlighter-rouge">1337</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jika objdump mencoba menggunakan deskriptor file tersebut, kita akan mengetahui sumbernya dan dapat mencoba mengaitkan interaksi apa pun dengan deskriptor file tersebut. Jadi sekarang </font></font><code class="language-plaintext highlighter-rouge">fopen64()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaitan kita akan terlihat seperti berikut:</font></font></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Our fopen hook, return a FILE* to the caller, also, if we are opening our</span>
<span class="c1">// target make sure we're not able to write to the file</span>
<span class="kt">FILE</span><span class="o">*</span> <span class="nf">fopen64</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Resolve symbol on demand and only once</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">real_fopen64</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">real_fopen64</span> <span class="o">=</span> <span class="n">_resolve_symbol</span><span class="p">(</span><span class="s">"fopen64"</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Check to see what file we're opening</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">FUZZ_TARGET</span><span class="p">,</span> <span class="n">pathname</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// We're trying to open our file, make sure it's a read-only mode</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="s">"r"</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Attempt to open fuzz-target in illegal mode: '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span><font></font>
<font></font>
        <span class="c1">// Open shared memory FILE* and return to caller</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">fmemopen</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">INPUT_ADDR</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span><span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span><font></font>
        <font></font>
        <span class="c1">// Make sure we've never fopen()'d our fuzzing target before</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">faked_fp</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Attempting to fopen64() fuzzing target more than once</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span><font></font>
<font></font>
        <span class="c1">// Update faked_fp</span>
        <span class="n">faked_fp</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span><font></font>
<font></font>
        <span class="c1">// Change the filedes to something we know</span>
        <span class="n">ret</span><span class="o">-&gt;</span><span class="n">_fileno</span> <span class="o">=</span> <span class="mi">1337</span><span class="p">;</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// We're not opening our file, send to regular fopen</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">real_fopen64</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Return FILE stream ptr to caller</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat melihat kami:</font></font></p>
<ol>
  <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selesaikan lokasi simbol jika belum</font></font></li>
  <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Periksa untuk melihat apakah kita dipanggil pada file input target fuzzing kita</font></font></li>
  <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggil </font></font><code class="language-plaintext highlighter-rouge">fmemopen()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan buka buffer memori tempat input kita saat ini berada di memori beserta ukuran inputnya</font></font></li>
</ol>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda mungkin juga memperhatikan beberapa pemeriksaan keamanan untuk memastikan hal-hal tidak luput dari perhatian. Kami memiliki variabel global yang </font></font><code class="language-plaintext highlighter-rouge">FILE *faked_fp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami inisialisasikan untuk </font></font><code class="language-plaintext highlighter-rouge">NULL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memberi tahu kami jika kami pernah membuka masukan lebih dari satu kali (tidak akan terjadi </font></font><code class="language-plaintext highlighter-rouge">NULL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lagi pada percobaan berikutnya untuk membukanya).</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami juga melakukan pemeriksaan pada </font></font><code class="language-plaintext highlighter-rouge">mode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">argumen untuk memastikan kami mendapatkan balasan hanya-baca </font></font><code class="language-plaintext highlighter-rouge">FILE *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kami tidak ingin objdump mengubah masukan kami atau menulis padanya dengan cara apa pun dan jika ia mencoba melakukannya, kami perlu mengetahuinya.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menjalankan objek yang kita bagikan pada titik ini akan menghasilkan output berikut:</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h0mbre@ubuntu:~/blogpost$ LD_PRELOAD=/home/h0mbre/blogpost/blog_harness.so objdump -D fuzzme<font></font>
objdump: fuzzme: Bad file descriptor<font></font>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spidey-sense saya memberi tahu saya bahwa ada sesuatu yang mencoba berinteraksi dengan deskriptor file </font></font><code class="language-plaintext highlighter-rouge">1337</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mari kita jalankan lagi </font></font><code class="language-plaintext highlighter-rouge">strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan lihat apa yang terjadi.</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h0mbre@ubuntu:~/blogpost$ strace -E LD_PRELOAD=/home/h0mbre/blogpost/blog_harness.so objdump -D fuzzme &gt; /tmp/output.txt
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada output, kita dapat melihat beberapa syscall ke </font></font><code class="language-plaintext highlighter-rouge">fcntl()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code class="language-plaintext highlighter-rouge">fstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keduanya dipanggil dengan deskriptor file yang </font></font><code class="language-plaintext highlighter-rouge">1337</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jelas-jelas tidak ada dalam proses objdump kita, jadi kita dapat menemukan masalahnya.</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fcntl(1337, F_GETFD)                    = -1 EBADF (Bad file descriptor)<font></font>
prlimit64(0, RLIMIT_NOFILE, NULL, {rlim_cur=4*1024, rlim_max=4*1024}) = 0<font></font>
fstat(1337, 0x7fff4bf54c90)             = -1 EBADF (Bad file descriptor)<font></font>
fstat(1337, 0x7fff4bf54bf0)             = -1 EBADF (Bad file descriptor)<font></font>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang telah kita pelajari, tidak ada ekspor langsung di libc untuk </font></font><code class="language-plaintext highlighter-rouge">fstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ini salah satu yang aneh seperti </font></font><code class="language-plaintext highlighter-rouge">stat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan kita benar-benar harus mengaitkan </font></font><code class="language-plaintext highlighter-rouge">__fxstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jadi mari kita coba dan mengaitkannya untuk melihat apakah itu dipanggil untuk </font></font><code class="language-plaintext highlighter-rouge">1337</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deskriptor file kita. Fungsi kait akan terlihat seperti ini untuk memulai:</font></font></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Declare prototype for the real __fxstat</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">__fxstat_t</span><span class="p">)(</span><span class="kt">int</span> <span class="n">__ver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__filedesc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">__stat_buf</span><span class="p">);</span>
<span class="n">__fxstat_t</span> <span class="n">real_fxstat</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
<span class="p">...</span><font></font>
<font></font>
<span class="c1">// Hook for __fxstat</span>
<span class="kt">int</span> <span class="nf">__fxstat</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__ver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__filedesc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">__stat_buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"** __fxstat() called for __filedesc: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__filedesc</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita juga masih harus </font></font><code class="language-plaintext highlighter-rouge">fcntl()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengatasinya, untungnya kaitan itu mudah, jika seseorang meminta </font></font><code class="language-plaintext highlighter-rouge">F_GETFD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aka, tanda yang dikaitkan dengan </font></font><code class="language-plaintext highlighter-rouge">1337</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deskriptor berkas khusus itu, kita akan mengembalikannya </font></font><code class="language-plaintext highlighter-rouge">O_RDONLY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai tanda yang digunakan untuk "membukanya", dan kita akan panik untuk saat ini jika seseorang memanggilnya untuk deskriptor berkas yang berbeda. Kaitan ini terlihat seperti ini:</font></font></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Declare prototype for the real __fcntl</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fcntl_t</span><span class="p">)(</span><span class="kt">int</span> <span class="n">fildes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...);</span>
<span class="n">fcntl_t</span> <span class="n">real_fcntl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
<span class="p">...</span><font></font>
<font></font>
<span class="c1">// Hook for fcntl</span>
<span class="kt">int</span> <span class="nf">fcntl</span><span class="p">(</span><span class="kt">int</span> <span class="n">fildes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="c1">// Resolve fcntl symbol if needed</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">real_fcntl</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">real_fcntl</span> <span class="o">=</span> <span class="n">_resolve_symbol</span><span class="p">(</span><span class="s">"fcntl"</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="k">if</span> <span class="p">(</span><span class="n">fildes</span> <span class="o">==</span> <span class="mi">1337</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">O_RDONLY</span><span class="p">;</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"** fcntl() called for real file descriptor</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika dijalankan </font></font><code class="language-plaintext highlighter-rouge">strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekarang, </font></font><code class="language-plaintext highlighter-rouge">fcntl()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panggilan tersebut tidak ada seperti yang kita harapkan:</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openat(AT_FDCWD, "/usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache", O_RDONLY) = 3<font></font>
fstat(3, {st_mode=S_IFREG|0644, st_size=26376, ...}) = 0<font></font>
mmap(NULL, 26376, PROT_READ, MAP_SHARED, 3, 0) = 0x7ff61d331000<font></font>
close(3)                                = 0<font></font>
prlimit64(0, RLIMIT_NOFILE, NULL, {rlim_cur=4*1024, rlim_max=4*1024}) = 0<font></font>
fstat(1, {st_mode=S_IFREG|0664, st_size=0, ...}) = 0<font></font>
write(1, "** __fxstat() called for __filed"..., 42) = 42<font></font>
exit_group(0)                           = ?<font></font>
+++ exited with 0 +++<font></font>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat menyempurnakan </font></font><code class="language-plaintext highlighter-rouge">__fxstat()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hook kita dengan beberapa logika. Pemanggil berharap untuk mengambil </font></font><code class="language-plaintext highlighter-rouge">stat struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari fungsi untuk target fuzzing kita </font></font><code class="language-plaintext highlighter-rouge">fuzzme</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan meneruskan deskriptor file khusus </font></font><code class="language-plaintext highlighter-rouge">1337</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Untungnya, kita memiliki global </font></font><code class="language-plaintext highlighter-rouge">stat struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang dapat kita kembalikan setelah kita memperbarui ukurannya agar sesuai dengan input saat ini dalam memori (seperti yang dilacak oleh kita dan fuzzer sebagai nilai pada </font></font><code class="language-plaintext highlighter-rouge">INPUT_SIZE_ADDR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Jadi jika dipanggil, kita cukup memperbarui </font></font><code class="language-plaintext highlighter-rouge">stat struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ukuran kita, dan </font></font><code class="language-plaintext highlighter-rouge">memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">struct kita ke dalam </font></font><code class="language-plaintext highlighter-rouge">*__stat_buf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Hook lengkap kita sekarang terlihat seperti ini:</font></font></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Hook for __fxstat</span>
<span class="kt">int</span> <span class="nf">__fxstat</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__ver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__filedesc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">__stat_buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Resolve the real fxstat</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">real_fxstat</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">real_fxstat</span> <span class="o">=</span> <span class="n">_resolve_symbol</span><span class="p">(</span><span class="s">"__fxstat"</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><font></font>
<font></font>
    <span class="c1">// Check to see if we're stat'ing our fuzz target</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">1337</span> <span class="o">==</span> <span class="n">__filedesc</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Patch the global struct with current input size</span>
        <span class="n">st</span><span class="p">.</span><span class="n">st_size</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span><span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span><span class="p">;</span><font></font>
<font></font>
        <span class="c1">// Copy global stat struct back to caller</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">__stat_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">stat</span><span class="p">));</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Normal stat, send to real fxstat</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">real_fxstat</span><span class="p">(</span><span class="n">__ver</span><span class="p">,</span> <span class="n">__filedesc</span><span class="p">,</span> <span class="n">__stat_buf</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang jika kita menjalankan ini, kita sebenarnya tidak rusak dan objdump dapat keluar dengan bersih di bawah </font></font><code class="language-plaintext highlighter-rouge">strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></p>

<h2 id="wrapping-up"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penutup</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menguji apakah kita telah melakukan pekerjaan yang adil atau tidak, kita akan melanjutkan dan mengeluarkannya </font></font><code class="language-plaintext highlighter-rouge">objdump -D fuzzme</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke sebuah berkas, lalu kita akan melanjutkan dan mengeluarkan perintah yang sama tetapi dengan objek bersama harness kita yang dimuat. Terakhir, kita akan menjalankan </font></font><code class="language-plaintext highlighter-rouge">objdump -D /bin/ed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mengeluarkannya ke sebuah berkas untuk melihat apakah harness kita menghasilkan keluaran yang sama.</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h0mbre@ubuntu:~/blogpost$ objdump -D fuzzme &gt; /tmp/fuzzme_original.txt      <font></font>
h0mbre@ubuntu:~/blogpost$ LD_PRELOAD=/home/h0mbre/blogpost/blog_harness.so objdump -D fuzzme &gt; /tmp/harness.txt <font></font>
h0mbre@ubuntu:~/blogpost$ objdump -D /bin/ed &gt; /tmp/ed.txt<font></font>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian kita </font></font><code class="language-plaintext highlighter-rouge">sha1sum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file-nya:</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h0mbre@ubuntu:~/blogpost$ sha1sum /tmp/fuzzme_original.txt /tmp/harness.txt /tmp/ed.txt <font></font>
938518c86301ab00ddf6a3ef528d7610fa3fd05a  /tmp/fuzzme_original.txt<font></font>
add4e6c3c298733f48fbfe143caee79445c2f196  /tmp/harness.txt<font></font>
10454308b672022b40f6ce5e32a6217612b462c8  /tmp/ed.txt<font></font>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami sebenarnya mendapatkan tiga hash yang berbeda, kami menginginkan harness dan </font></font><code class="language-plaintext highlighter-rouge">/bin/ed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengeluarkan output yang sama karena </font></font><code class="language-plaintext highlighter-rouge">/bin/ed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merupakan input yang kami muat ke dalam memori.</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h0mbre@ubuntu:~/blogpost$ ls -laht /tmp<font></font>
total 14M<font></font>
drwxrwxrwt 28 root   root   128K Apr  3 08:44 .<font></font>
-rw-rw-r--  1 h0mbre h0mbre 736K Apr  3 08:43 ed.txt<font></font>
-rw-rw-r--  1 h0mbre h0mbre 736K Apr  3 08:43 harness.txt<font></font>
-rw-rw-r--  1 h0mbre h0mbre 2.2M Apr  3 08:42 fuzzme_original.txt<font></font>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ah, setidaknya panjangnya sama, itu pasti berarti ada perbedaan yang halus dan </font></font><code class="language-plaintext highlighter-rouge">diff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunjukkan kepada kita mengapa hashnya tidak sama:</font></font></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h0mbre@ubuntu:~/blogpost$ diff /tmp/ed.txt /tmp/harness.txt <font></font>
2c2<font></font>
&lt; /bin/ed:     file format elf64-x86-64<font></font>
---<font></font>
&gt; fuzzme:     file format elf64-x86-64<font></font>
</code></pre></div></div>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nama berkas dalam </font></font><code class="language-plaintext highlighter-rouge">argv[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array berbeda, jadi hanya itu perbedaannya. Pada akhirnya kami dapat memasukkan berkas input ke objdump, tetapi sebenarnya mengambil input dari buffer dalam memori di harness kami.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu hal lagi, kita sebenarnya lupa bahwa objdump menutup berkas kita, bukan? Jadi saya lanjutkan dan tambahkan </font></font><code class="language-plaintext highlighter-rouge">fclose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaitan cepat. Kita tidak akan mengalami masalah jika </font></font><code class="language-plaintext highlighter-rouge">fclose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya ingin membebaskan memori heap yang terkait dengan </font></font><code class="language-plaintext highlighter-rouge">fmemopen()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font></font><code class="language-plaintext highlighter-rouge">FILE *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">namun, ia mungkin juga akan mencoba memanggil </font></font><code class="language-plaintext highlighter-rouge">close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deskriptor berkas yang tidak stabil itu dan kita tidak menginginkannya. Itu mungkin tidak penting pada akhirnya, kita hanya ingin aman. Terserah pembaca untuk bereksperimen dan melihat perubahan apa yang terjadi. Fuzzer imajiner harus memulihkan </font></font><code class="language-plaintext highlighter-rouge">FILE *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memori heap selama rutinitas pemulihan snapshot-nya.</font></font></p>

<h2 id="conclusion"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></h2>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada sejuta cara berbeda untuk mencapai tujuan ini, saya hanya ingin memandu Anda melalui proses berpikir saya. Sebenarnya ada banyak hal keren yang dapat Anda lakukan dengan harness ini, satu hal yang telah saya lakukan adalah benar-benar melakukan hook </font></font><code class="language-plaintext highlighter-rouge">malloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to fail pada alokasi besar sehingga saya tidak membuang siklus fuzzing pada hal-hal yang pada akhirnya akan habis waktunya. Anda juga dapat membuat </font></font><code class="language-plaintext highlighter-rouge">at_exit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">choke point sehingga apa pun yang terjadi, program tersebut mengeksekusi </font></font><code class="language-plaintext highlighter-rouge">at_exit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fungsi Anda setiap kali keluar yang dapat berguna untuk pengaturan ulang snapshot jika program dapat mengambil beberapa jalur keluar karena Anda hanya perlu menutupi satu titik keluar.</font></font></p>

<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semoga ini bermanfaat bagi sebagian orang! Kode lengkap untuk harness ada di bawah, selamat mencoba!</font></font></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 
Compiler flags: 
gcc -shared -Wall -Werror -fPIC blog_harness.c -o blog_harness.so -ldl
*/</span><font></font>
<font></font>
<span class="cp">#define _GNU_SOURCE     </span><span class="cm">/* dlsym */</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> /* printf */</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="c1"> /* stat */</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="c1"> /* exit */</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="c1"> /* __xstat, __fxstat */</span><span class="cp">
#include</span> <span class="cpf">&lt;dlfcn.h&gt;</span><span class="c1"> /* dlsym and friends */</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="c1"> /* mmap */</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="c1"> /* memset */</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="c1"> /* open */</span><span class="cp">
</span>
<span class="c1">// Filename of the input file we're trying to emulate</span>
<span class="cp">#define FUZZ_TARGET     "fuzzme"
</span>
<span class="c1">// Definitions for our in-memory inputs </span>
<span class="cp">#define INPUT_SZ_ADDR   0x1336000
#define INPUT_ADDR      0x1337000
#define MAX_INPUT_SZ    (1024 * 1024)
</span>
<span class="c1">// For testing purposes, we read /bin/ed into our input buffer to simulate</span>
<span class="c1">// what the fuzzer would do</span>
<span class="cp">#define  TEST_FILE      "/bin/ed"
</span>
<span class="c1">// Our "legit" global stat struct</span>
<span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span><font></font>
<font></font>
<span class="c1">// FILE * returned to callers of fopen64() </span>
<span class="kt">FILE</span> <span class="o">*</span><span class="n">faked_fp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
<span class="c1">// Declare a prototype for the real stat as a function pointer</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">__xstat_t</span><span class="p">)(</span><span class="kt">int</span> <span class="n">__ver</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">__filename</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">__stat_buf</span><span class="p">);</span>
<span class="n">__xstat_t</span> <span class="n">real_xstat</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
<span class="c1">// Declare prototype for the real fopen and its friend fopen64 </span>
<span class="k">typedef</span> <span class="kt">FILE</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">fopen_t</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span><span class="p">);</span>
<span class="n">fopen_t</span> <span class="n">real_fopen</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
<span class="k">typedef</span> <span class="kt">FILE</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">fopen64_t</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span><span class="p">);</span>
<span class="n">fopen64_t</span> <span class="n">real_fopen64</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
<span class="c1">// Declare prototype for the real __fxstat</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">__fxstat_t</span><span class="p">)(</span><span class="kt">int</span> <span class="n">__ver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__filedesc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">__stat_buf</span><span class="p">);</span>
<span class="n">__fxstat_t</span> <span class="n">real_fxstat</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
<span class="c1">// Declare prototype for the real __fcntl</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fcntl_t</span><span class="p">)(</span><span class="kt">int</span> <span class="n">fildes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...);</span>
<span class="n">fcntl_t</span> <span class="n">real_fcntl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
<span class="c1">// Returns memory address of *next* location of symbol in library search order</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">_resolve_symbol</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symbol</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Clear previous errors</span>
    <span class="n">dlerror</span><span class="p">();</span><font></font>
<font></font>
    <span class="c1">// Get symbol address</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="n">symbol</span><span class="p">);</span><font></font>
<font></font>
    <span class="c1">// Check for error</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">err</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">dlerror</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"** Err resolving '%s' addr: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><font></font>
    <font></font>
    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Hook for __xstat </span>
<span class="kt">int</span> <span class="nf">__xstat</span><span class="p">(</span><span class="kt">int</span> <span class="n">__ver</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">__filename</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span><span class="o">*</span> <span class="n">__stat_buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Resolve the real __xstat() on demand and maybe multiple times!</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">real_xstat</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">real_xstat</span> <span class="o">=</span> <span class="n">_resolve_symbol</span><span class="p">(</span><span class="s">"__xstat"</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Assume the worst, always</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><font></font>
<font></font>
    <span class="c1">// Special __ver value check to see if we're calling from constructor</span>
    <span class="k">if</span> <span class="p">(</span><span class="mh">0x1337</span> <span class="o">==</span> <span class="n">__ver</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Patch back up the version value before sending to real xstat</span>
        <span class="n">__ver</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><font></font>
<font></font>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">real_xstat</span><span class="p">(</span><span class="n">__ver</span><span class="p">,</span> <span class="n">__filename</span><span class="p">,</span> <span class="n">__stat_buf</span><span class="p">);</span><font></font>
<font></font>
        <span class="c1">// Set the real_xstat back to NULL</span>
        <span class="n">real_xstat</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Determine if we're stat'ing our fuzzing target</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">__filename</span><span class="p">,</span> <span class="n">FUZZ_TARGET</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// Update our global stat struct</span>
        <span class="n">st</span><span class="p">.</span><span class="n">st_size</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span><span class="p">;</span><font></font>
<font></font>
        <span class="c1">// Send it back to the caller, skip syscall</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">__stat_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">stat</span><span class="p">));</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Just a normal stat, send to real xstat</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">real_xstat</span><span class="p">(</span><span class="n">__ver</span><span class="p">,</span> <span class="n">__filename</span><span class="p">,</span> <span class="n">__stat_buf</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Exploratory hooks to see if we're using fopen() related functions to open</span>
<span class="c1">// our input file</span>
<span class="kt">FILE</span><span class="o">*</span> <span class="nf">fopen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"** fopen() called for '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pathname</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Our fopen hook, return a FILE* to the caller, also, if we are opening our</span>
<span class="c1">// target make sure we're not able to write to the file</span>
<span class="kt">FILE</span><span class="o">*</span> <span class="nf">fopen64</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Resolve symbol on demand and only once</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">real_fopen64</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">real_fopen64</span> <span class="o">=</span> <span class="n">_resolve_symbol</span><span class="p">(</span><span class="s">"fopen64"</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Check to see what file we're opening</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">FUZZ_TARGET</span><span class="p">,</span> <span class="n">pathname</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// We're trying to open our file, make sure it's a read-only mode</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="s">"r"</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"** Attempt to open fuzz-target in illegal mode: '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span><font></font>
<font></font>
        <span class="c1">// Open shared memory FILE* and return to caller</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">fmemopen</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">INPUT_ADDR</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span><span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span><font></font>
        <font></font>
        <span class="c1">// Make sure we've never fopen()'d our fuzzing target before</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">faked_fp</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"** Attempting to fopen64() fuzzing target more than once</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span><font></font>
<font></font>
        <span class="c1">// Update faked_fp</span>
        <span class="n">faked_fp</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span><font></font>
<font></font>
        <span class="c1">// Change the filedes to something we know</span>
        <span class="n">ret</span><span class="o">-&gt;</span><span class="n">_fileno</span> <span class="o">=</span> <span class="mi">1337</span><span class="p">;</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// We're not opening our file, send to regular fopen</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">real_fopen64</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Return FILE stream ptr to caller</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Hook for __fxstat</span>
<span class="kt">int</span> <span class="nf">__fxstat</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__ver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__filedesc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">__stat_buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Resolve the real fxstat</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">real_fxstat</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">real_fxstat</span> <span class="o">=</span> <span class="n">_resolve_symbol</span><span class="p">(</span><span class="s">"__fxstat"</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><font></font>
<font></font>
    <span class="c1">// Check to see if we're stat'ing our fuzz target</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">1337</span> <span class="o">==</span> <span class="n">__filedesc</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Patch the global struct with current input size</span>
        <span class="n">st</span><span class="p">.</span><span class="n">st_size</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span><span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span><span class="p">;</span><font></font>
<font></font>
        <span class="c1">// Copy global stat struct back to caller</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">__stat_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">stat</span><span class="p">));</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Normal stat, send to real fxstat</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">real_fxstat</span><span class="p">(</span><span class="n">__ver</span><span class="p">,</span> <span class="n">__filedesc</span><span class="p">,</span> <span class="n">__stat_buf</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Hook for fcntl</span>
<span class="kt">int</span> <span class="nf">fcntl</span><span class="p">(</span><span class="kt">int</span> <span class="n">fildes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="c1">// Resolve fcntl symbol if needed</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">real_fcntl</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">real_fcntl</span> <span class="o">=</span> <span class="n">_resolve_symbol</span><span class="p">(</span><span class="s">"fcntl"</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="k">if</span> <span class="p">(</span><span class="n">fildes</span> <span class="o">==</span> <span class="mi">1337</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">O_RDONLY</span><span class="p">;</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"** fcntl() called for real file descriptor</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Map memory to hold our inputs in memory and information about their size</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_create_mem_mappings</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><font></font>
<font></font>
    <span class="c1">// Map the page to hold the input size</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
        <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">INPUT_SZ_ADDR</span><span class="p">),</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">),</span>
        <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
        <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_FIXED</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">MAP_FAILED</span> <span class="o">==</span> <span class="n">result</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"** Err mapping INPUT_SZ_ADDR, mapped @ %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Let's actually initialize the value at the input size location as well</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><font></font>
<font></font>
    <span class="c1">// Map the pages to hold the input contents</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span>
        <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">INPUT_ADDR</span><span class="p">),</span>
        <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">MAX_INPUT_SZ</span><span class="p">),</span>
        <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
        <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_FIXED</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="mi">0</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">MAP_FAILED</span> <span class="o">==</span> <span class="n">result</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_ADDR</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"** Err mapping INPUT_ADDR, mapped @ %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Init the value</span>
    <span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_ADDR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">MAX_INPUT_SZ</span><span class="p">);</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Create a "legit" stat struct globally to pass to callers</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_setup_stat_struct</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">__xstat</span><span class="p">(</span><span class="mh">0x1337</span><span class="p">,</span> <span class="n">FUZZ_TARGET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"** Err creating stat struct for '%s' during load</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">FUZZ_TARGET</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span><font></font>
<font></font>
<span class="c1">// Used for testing, load /bin/ed into the input buffer and update its size info</span>
<span class="cp">#ifdef TEST
</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">_test_func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>    
    <span class="c1">// Open TEST_FILE for reading</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">TEST_FILE</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"** Failed to open '%s' during test</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">TEST_FILE</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><font></font>
<font></font>
    <span class="c1">// Attempt to read max input buf size</span>
    <span class="kt">ssize_t</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">INPUT_ADDR</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">MAX_INPUT_SZ</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span><font></font>
<font></font>
    <span class="c1">// Update the input size</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)</span><span class="n">INPUT_SZ_ADDR</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">bytes</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif
</span>
<span class="c1">// Routine to be called when our shared object is loaded</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">_hook_load</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Create memory mappings to hold our input and information about its size</span>
    <span class="n">_create_mem_mappings</span><span class="p">();</span><font></font>
<font></font>
    <span class="c1">// Setup global "legit" stat struct</span>
    <span class="n">_setup_stat_struct</span><span class="p">();</span><font></font>
<font></font>
    <span class="c1">// If we're testing, load /bin/ed up into our input buffer and update size</span>
<span class="cp">#ifdef TEST
</span>    <span class="n">_test_func</span><span class="p">();</span>
<span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

  </div>
</article>
      </div>
    </main><footer class="site-footer">
    <div class="wrapper">
      <div class="social-links"><ul class="social-media-list"><li><a href="https://github.com/h0mbre"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pria</font></font></span></a></li><li><a href="https://www.twitter.com/h0mbre_"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h0mbre_</font></font></span></a></li></ul>
</div>
    </div>
  </footer><div id="goog-gt-tt" class="VIpgJd-yAWNEb-L7lbkb skiptranslate" style="border-radius: 12px; margin: 0 0 0 -23px; padding: 0; font-family: 'Google Sans', Arial, sans-serif;" data-id=""><div id="goog-gt-vt" class="VIpgJd-yAWNEb-hvhgNd"><div class=" VIpgJd-yAWNEb-hvhgNd-l4eHX-i3jM8c"><img src="https://fonts.gstatic.com/s/i/productlogos/translate/v14/24px.svg" width="24" height="24" alt=""></div><div class=" VIpgJd-yAWNEb-hvhgNd-k77Iif-i3jM8c"><div class="VIpgJd-yAWNEb-hvhgNd-IuizWc" dir="ltr">Teks asli</div><div id="goog-gt-original-text" class="VIpgJd-yAWNEb-nVMfcd-fmcmS VIpgJd-yAWNEb-hvhgNd-axAV1"></div></div><div class="VIpgJd-yAWNEb-hvhgNd-N7Eqid ltr"><div class="VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od ltr" dir="ltr"><div class="VIpgJd-yAWNEb-hvhgNd-UTujCb">Beri rating terjemahan ini</div><div class="VIpgJd-yAWNEb-hvhgNd-eO9mKe">Masukan Anda akan digunakan untuk membantu meningkatkan kualitas Google Terjemahan</div></div><div class="VIpgJd-yAWNEb-hvhgNd-xgov5 ltr"><button id="goog-gt-thumbUpButton" type="button" class="VIpgJd-yAWNEb-hvhgNd-bgm6sf" title="Terjemahan bagus" aria-label="Terjemahan bagus" aria-pressed="false"><span id="goog-gt-thumbUpIcon"><svg width="24" height="24" viewBox="0 0 24 24" focusable="false" class="VIpgJd-yAWNEb-hvhgNd-THI6Vb NMm5M"><path d="M21 7h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 0S7.08 6.85 7 7H2v13h16c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73V9c0-1.1-.9-2-2-2zM7 18H4V9h3v9zm14-7l-3 7H9V8l4.34-4.34L12 9h9v2z"></path></svg></span><span id="goog-gt-thumbUpIconFilled"><svg width="24" height="24" viewBox="0 0 24 24" focusable="false" class="VIpgJd-yAWNEb-hvhgNd-THI6Vb NMm5M"><path d="M21 7h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 0S7.08 6.85 7 7v13h11c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73V9c0-1.1-.9-2-2-2zM5 7H1v13h4V7z"></path></svg></span></button><button id="goog-gt-thumbDownButton" type="button" class="VIpgJd-yAWNEb-hvhgNd-bgm6sf" title="Terjemahan buruk" aria-label="Terjemahan buruk" aria-pressed="false"><span id="goog-gt-thumbDownIcon"><svg width="24" height="24" viewBox="0 0 24 24" focusable="false" class="VIpgJd-yAWNEb-hvhgNd-THI6Vb NMm5M"><path d="M3 17h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 24s7.09-6.85 7.17-7h5V4H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2zM17 6h3v9h-3V6zM3 13l3-7h9v10l-4.34 4.34L12 15H3v-2z"></path></svg></span><span id="goog-gt-thumbDownIconFilled"><svg width="24" height="24" viewBox="0 0 24 24" focusable="false" class="VIpgJd-yAWNEb-hvhgNd-THI6Vb NMm5M"><path d="M3 17h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 24s7.09-6.85 7.17-7V4H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2zm16 0h4V4h-4v13z"></path></svg></span></button></div></div><div id="goog-gt-votingHiddenPane" class="VIpgJd-yAWNEb-hvhgNd-aXYTce"><form id="goog-gt-votingForm" action="https://translate.googleapis.com/translate_voting?client=te_lib" method="post" target="votingFrame" class="VIpgJd-yAWNEb-hvhgNd-aXYTce"><input type="text" name="sl" id="goog-gt-votingInputSrcLang"><input type="text" name="tl" id="goog-gt-votingInputTrgLang"><input type="text" name="query" id="goog-gt-votingInputSrcText"><input type="text" name="gtrans" id="goog-gt-votingInputTrgText"><input type="text" name="vote" id="goog-gt-votingInputVote"></form><iframe name="votingFrame" frameborder="0"></iframe></div></div></div>
</body></html>
------MultipartBoundary--UL36Vsa5HO0TbB8lkGoRqqA9W8Bsi7tgULfaVjMKY5----
Content-Type: text/css
Content-Transfer-Encoding: binary
Content-Location: https://h0mbre.github.io/assets/main.css

@charset "utf-8";

@import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap");

@font-face { font-family: "GNU Unifont"; src: url("/assets/fonts/unifont-15.1.05.otf") format("opentype"); }

@font-face { font-family: "Perfect DOS VGA 437"; src: url("/assets/fonts/Perfect DOS VGA 437.ttf") format("truetype"); }

body, h1, h2, h3, h4, h5, h6, p, blockquote, pre, hr, dl, dd, ol, ul, figure { margin: 0px; padding: 0px; }

body { font-style: normal; font-variant: normal; font-optical-sizing: auto; font-variation-settings: normal; font-weight: 400; font-stretch: normal; font-size: 16px; line-height: 1.5; font-family: "GNU Unifont", monospace; color: rgb(17, 17, 17); background-color: rgb(253, 253, 253); text-size-adjust: 100%; font-feature-settings: "kern"; font-kerning: normal; display: flex; min-height: 100vh; flex-direction: column; }

h1, h2, h3, h4, h5, h6, p, blockquote, pre, ul, ol, dl, figure, .highlight { margin-bottom: 15px; }

main { display: block; }

img { max-width: 100%; vertical-align: middle; }

figure > img { display: block; }

figcaption { font-size: 14px; }

ul, ol { margin-left: 30px; }

li > ul, li > ol { margin-bottom: 0px; }

h1, h2, h3, h4, h5, h6 { font-weight: 400; }

a { color: rgb(42, 122, 226); text-decoration: none; }

a:visited { color: rgb(23, 86, 169); }

a:hover { color: rgb(17, 17, 17); text-decoration: underline; }

.social-media-list a:hover { text-decoration: none; }

.social-media-list a:hover .username { text-decoration: underline; }

blockquote { color: rgb(130, 130, 130); border-left: 4px solid rgb(232, 232, 232); padding-left: 15px; font-size: 18px; letter-spacing: -1px; font-style: italic; }

blockquote > :last-child { margin-bottom: 0px; }

pre, code { font-size: 15px; border: 1px solid rgb(232, 232, 232); border-radius: 3px; background-color: rgb(238, 238, 255); }

code { padding: 1px 5px; }

pre { padding: 8px 12px; overflow-x: auto; }

pre > code { border: 0px; padding-right: 0px; padding-left: 0px; }

.wrapper { max-width: calc(940px); margin-right: auto; margin-left: auto; padding-right: 30px; padding-left: 30px; }

@media screen and (max-width: 800px) {
  .wrapper { max-width: calc(970px); padding-right: 15px; padding-left: 15px; }
}

.wrapper::after, .footer-col-wrapper::after { content: ""; display: table; clear: both; }

.svg-icon { width: 16px; height: 16px; display: inline-block; fill: rgb(130, 130, 130); padding-right: 5px; vertical-align: text-top; }

.social-media-list li + li { padding-top: 5px; }

table { margin-bottom: 30px; width: 100%; text-align: left; color: rgb(63, 63, 63); border-collapse: collapse; border: 1px solid rgb(232, 232, 232); }

table tr:nth-child(2n) { background-color: rgb(247, 247, 247); }

table th, table td { padding: 10px 15px; }

table th { background-color: rgb(240, 240, 240); border-width: 1px; border-style: solid; border-color: rgb(222, 222, 222) rgb(222, 222, 222) rgb(201, 201, 201); border-image: initial; }

table td { border: 1px solid rgb(232, 232, 232); }

.site-header { border-top: 5px solid rgb(66, 66, 66); border-bottom: 1px solid rgb(232, 232, 232); min-height: 55.95px; position: relative; }

.site-title { font-size: 26px; font-weight: 300; line-height: 54px; letter-spacing: -1px; margin-bottom: 0px; float: left; }

.site-title, .site-title:visited { color: rgb(66, 66, 66); }

.site-nav { float: right; line-height: 54px; }

.site-nav .nav-trigger { display: none; }

.site-nav .menu-icon { display: none; }

.site-nav .page-link { color: rgb(17, 17, 17); line-height: 1.5; }

.site-nav .page-link:not(:last-child) { margin-right: 20px; }

@media screen and (max-width: 600px) {
  .site-nav { position: absolute; top: 9px; right: 15px; background-color: rgb(253, 253, 253); border: 1px solid rgb(232, 232, 232); border-radius: 5px; text-align: right; }
  .site-nav label[for="nav-trigger"] { display: block; float: right; width: 36px; height: 36px; z-index: 2; cursor: pointer; }
  .site-nav .menu-icon { display: block; float: right; width: 36px; height: 26px; line-height: 0; padding-top: 10px; text-align: center; }
  .site-nav .menu-icon > svg { fill: rgb(66, 66, 66); }
  .site-nav input ~ .trigger { clear: both; display: none; }
  .site-nav input:checked ~ .trigger { display: block; padding-bottom: 5px; }
  .site-nav .page-link { display: block; padding: 5px 10px; margin-left: 20px; }
  .site-nav .page-link:not(:last-child) { margin-right: 0px; }
}

.site-footer { border-top: 1px solid rgb(232, 232, 232); padding: 30px 0px; }

.footer-heading { font-size: 18px; margin-bottom: 15px; }

.contact-list, .social-media-list { list-style: none; margin-left: 0px; }

.footer-col-wrapper { font-size: 15px; color: rgb(130, 130, 130); margin-left: -15px; }

.footer-col { float: left; margin-bottom: 15px; padding-left: 15px; }

.footer-col-1 { width: calc(35% - 15px); }

.footer-col-2 { width: calc(20% - 15px); }

.footer-col-3 { width: calc(45% - 15px); }

@media screen and (max-width: 800px) {
  .footer-col-1, .footer-col-2 { width: calc(50% - 15px); }
  .footer-col-3 { width: calc(100% - 15px); }
}

@media screen and (max-width: 600px) {
  .footer-col { float: none; width: calc(100% - 15px); }
}

.page-content { padding: 30px 0px; flex: 1 1 0%; }

.page-heading { font-size: 32px; }

.post-list-heading { font-size: 28px; }

.post-list { margin-left: 0px; list-style: none; }

.post-list > li { margin-bottom: 30px; }

.post-meta { font-size: 14px; color: rgb(130, 130, 130); }

.post-link { display: block; font-size: 24px; }

.post-header { margin-bottom: 30px; }

.post-title { font-size: 42px; letter-spacing: -1px; line-height: 1; }

@media screen and (max-width: 800px) {
  .post-title { font-size: 36px; }
}

.post-content { margin-bottom: 30px; }

.post-content h2 { font-size: 32px; }

@media screen and (max-width: 800px) {
  .post-content h2 { font-size: 28px; }
}

.post-content h3 { font-size: 26px; }

@media screen and (max-width: 800px) {
  .post-content h3 { font-size: 22px; }
}

.post-content h4 { font-size: 20px; }

@media screen and (max-width: 800px) {
  .post-content h4 { font-size: 18px; }
}

.highlight { background: rgb(255, 255, 255); }

.highlighter-rouge .highlight { background: rgb(238, 238, 255); }

.highlight .c { color: rgb(153, 153, 136); font-style: italic; }

.highlight .err { color: rgb(166, 23, 23); background-color: rgb(227, 210, 210); }

.highlight .k { font-weight: bold; }

.highlight .o { font-weight: bold; }

.highlight .cm { color: rgb(153, 153, 136); font-style: italic; }

.highlight .cp { color: rgb(153, 153, 153); font-weight: bold; }

.highlight .c1 { color: rgb(153, 153, 136); font-style: italic; }

.highlight .cs { color: rgb(153, 153, 153); font-weight: bold; font-style: italic; }

.highlight .gd { color: rgb(0, 0, 0); background-color: rgb(255, 221, 221); }

.highlight .gd .x { color: rgb(0, 0, 0); background-color: rgb(255, 170, 170); }

.highlight .ge { font-style: italic; }

.highlight .gr { color: rgb(170, 0, 0); }

.highlight .gh { color: rgb(153, 153, 153); }

.highlight .gi { color: rgb(0, 0, 0); background-color: rgb(221, 255, 221); }

.highlight .gi .x { color: rgb(0, 0, 0); background-color: rgb(170, 255, 170); }

.highlight .go { color: rgb(136, 136, 136); }

.highlight .gp { color: rgb(85, 85, 85); }

.highlight .gs { font-weight: bold; }

.highlight .gu { color: rgb(170, 170, 170); }

.highlight .gt { color: rgb(170, 0, 0); }

.highlight .kc { font-weight: bold; }

.highlight .kd { font-weight: bold; }

.highlight .kp { font-weight: bold; }

.highlight .kr { font-weight: bold; }

.highlight .kt { color: rgb(68, 85, 136); font-weight: bold; }

.highlight .m { color: rgb(0, 153, 153); }

.highlight .s { color: rgb(221, 17, 68); }

.highlight .na { color: teal; }

.highlight .nb { color: rgb(0, 134, 179); }

.highlight .nc { color: rgb(68, 85, 136); font-weight: bold; }

.highlight .no { color: teal; }

.highlight .ni { color: purple; }

.highlight .ne { color: rgb(153, 0, 0); font-weight: bold; }

.highlight .nf { color: rgb(153, 0, 0); font-weight: bold; }

.highlight .nn { color: rgb(85, 85, 85); }

.highlight .nt { color: navy; }

.highlight .nv { color: teal; }

.highlight .ow { font-weight: bold; }

.highlight .w { color: rgb(187, 187, 187); }

.highlight .mf { color: rgb(0, 153, 153); }

.highlight .mh { color: rgb(0, 153, 153); }

.highlight .mi { color: rgb(0, 153, 153); }

.highlight .mo { color: rgb(0, 153, 153); }

.highlight .sb { color: rgb(221, 17, 68); }

.highlight .sc { color: rgb(221, 17, 68); }

.highlight .sd { color: rgb(221, 17, 68); }

.highlight .s2 { color: rgb(221, 17, 68); }

.highlight .se { color: rgb(221, 17, 68); }

.highlight .sh { color: rgb(221, 17, 68); }

.highlight .si { color: rgb(221, 17, 68); }

.highlight .sx { color: rgb(221, 17, 68); }

.highlight .sr { color: rgb(0, 153, 38); }

.highlight .s1 { color: rgb(221, 17, 68); }

.highlight .ss { color: rgb(153, 0, 115); }

.highlight .bp { color: rgb(153, 153, 153); }

.highlight .vc { color: teal; }

.highlight .vg { color: teal; }

.highlight .vi { color: teal; }

.highlight .il { color: rgb(0, 153, 153); }

body { font-family: "GNU Unifont", monospace; color: rgb(29, 30, 32); }

body.post-page { background-color: rgb(123, 146, 191); }

body.home-page { background-color: rgb(0, 128, 128); }

.main-content { max-width: 1000px; margin: 0px auto; padding: 1rem; background-color: rgb(197, 201, 199); box-shadow: rgb(102, 102, 102) 5px 5px 0px; border-radius: 0px; width: 100%; box-sizing: border-box; }

.post-meta { color: black; margin-top: 0.1rem; font-size: 0.875rem; }

.home-content a { color: black; }

body.post-page h1, body.home-page h1, body.post-page h2, body.home-page h2, body.post-page h3, body.home-page h3, body.post-page h4, body.home-page h4, body.post-page h5, body.home-page h5, body.post-page h6, body.home-page h6, .post-title { font-family: "GNU Unifont", monospace; color: rgb(29, 30, 32); }

body.post-page h1, body.home-page h1 { font-size: 1.2rem; }

body.post-page h2, body.home-page h2 { font-size: 1.1rem; }

body.post-page h3, body.home-page h3 { font-size: 1rem; }

body.post-page h4, body.home-page h4 { font-size: 0.9rem; }

body.post-page h5, body.home-page h5 { font-size: 0.8rem; }

body.post-page h6, body.home-page h6 { font-size: 0.7rem; }

body.post-page h1, body.post-page h2, body.post-page h3, body.post-page h4, body.post-page h5, body.post-page h6 { text-decoration: underline; }

.home-content .post-link { font-family: "Perfect DOS VGA 437", sans-serif; }

.site-header { background-color: rgb(51, 51, 51); padding: 1rem 0px; border-bottom: 2px solid rgb(102, 102, 102); display: flex; justify-content: center; align-items: center; }

.wrapper { display: flex; justify-content: center; align-items: center; width: 100%; padding: 0px 1rem; position: relative; }

.social-links { position: absolute; left: 1rem; display: flex; align-items: center; }

.social-links a { color: white; margin-right: 1rem; text-decoration: none; }

.site-footer { background-color: rgb(51, 51, 51); padding: 3rem 0px; border-top: 2px solid rgb(102, 102, 102); }

.site-title { font-family: "GNU Unifont", monospace; font-size: 2rem; text-align: center; display: block; color: rgb(240, 240, 240) !important; }

.highlight pre, .highlight code { font-family: "JetBrains Mono", Consolas, "Courier New", monospace; font-size: 0.95em; }

p code, li code, span code { font-size: 0.875em; font-family: "JetBrains Mono", Consolas, "Courier New", monospace; }

.doc-icon { width: 24px; height: 24px; min-width: 24px; min-height: 24px; margin-right: 0.5rem; vertical-align: middle; }

.post-item { margin-bottom: 1rem; }

.post-details { display: flex; align-items: center; }

.post-details .post-link { margin-left: 0.5rem; font-size: 1rem; color: white; }

.post-list .post-meta { margin-left: 0.5rem; font-size: 0.875rem; color: white; }

.post .post-header, .post .post-content { padding: 0px 1rem; }

@media (max-width: 768px) {
  body { font-size: 14px; }
  .site-header { flex-direction: column; align-items: center; padding: 0.5rem 0px; }
  .social-links { position: static; margin-bottom: 1rem; }
  .site-title { font-size: 1.5rem; width: 100%; text-align: center; }
  .wrapper { padding: 0px; }
  .doc-icon { width: 24px; height: 24px; }
  .post-details { display: flex; align-items: center; }
  .post-item { margin-bottom: 1rem; }
  .main-content { margin: 0px; padding: 0.5rem; width: calc(100% - 1rem); box-shadow: rgb(102, 102, 102) 3px 3px 0px; }
  .post .post-header, .post .post-content { padding: 0px 0.5rem; }
  p, h1, h2, h3, h4, h5, h6 { overflow-wrap: break-word; }
  .post-title { font-size: 1.5rem; }
  .post-content h2 { font-size: 1.25rem; }
  .post-content h3 { font-size: 1.1rem; }
  .post-content h4 { font-size: 1rem; }
}

@media (max-width: 480px) {
  .main-content { width: calc(100% - 1rem); margin: 0.5rem auto; padding: 0.5rem; }
  .post-title { font-size: 1.3rem; }
  .post-content h2 { font-size: 1.2rem; }
  .post-content h3 { font-size: 1.1rem; }
  .post-content h4 { font-size: 1rem; }
}
------MultipartBoundary--UL36Vsa5HO0TbB8lkGoRqqA9W8Bsi7tgULfaVjMKY5----
Content-Type: text/css
Content-Transfer-Encoding: binary
Content-Location: https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap

@charset "utf-8";

@font-face { font-family: "JetBrains Mono"; font-style: normal; font-weight: 400; font-display: swap; src: url("https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx3cwgknk-6nFg.woff2") format("woff2"); unicode-range: U+460-52F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F; }

@font-face { font-family: "JetBrains Mono"; font-style: normal; font-weight: 400; font-display: swap; src: url("https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxTcwgknk-6nFg.woff2") format("woff2"); unicode-range: U+301, U+400-45F, U+490-491, U+4B0-4B1, U+2116; }

@font-face { font-family: "JetBrains Mono"; font-style: normal; font-weight: 400; font-display: swap; src: url("https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxPcwgknk-6nFg.woff2") format("woff2"); unicode-range: U+370-377, U+37A-37F, U+384-38A, U+38C, U+38E-3A1, U+3A3-3FF; }

@font-face { font-family: "JetBrains Mono"; font-style: normal; font-weight: 400; font-display: swap; src: url("https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx_cwgknk-6nFg.woff2") format("woff2"); unicode-range: U+102-103, U+110-111, U+128-129, U+168-169, U+1A0-1A1, U+1AF-1B0, U+300-301, U+303-304, U+308-309, U+323, U+329, U+1EA0-1EF9, U+20AB; }

@font-face { font-family: "JetBrains Mono"; font-style: normal; font-weight: 400; font-display: swap; src: url("https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx7cwgknk-6nFg.woff2") format("woff2"); unicode-range: U+100-2BA, U+2BD-2C5, U+2C7-2CC, U+2CE-2D7, U+2DD-2FF, U+304, U+308, U+329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF; }

@font-face { font-family: "JetBrains Mono"; font-style: normal; font-weight: 400; font-display: swap; src: url("https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxDcwgknk-4.woff2") format("woff2"); unicode-range: U+0-FF, U+131, U+152-153, U+2BB-2BC, U+2C6, U+2DA, U+2DC, U+304, U+308, U+329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; }

@font-face { font-family: "JetBrains Mono"; font-style: normal; font-weight: 700; font-display: swap; src: url("https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx3cwgknk-6nFg.woff2") format("woff2"); unicode-range: U+460-52F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F; }

@font-face { font-family: "JetBrains Mono"; font-style: normal; font-weight: 700; font-display: swap; src: url("https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxTcwgknk-6nFg.woff2") format("woff2"); unicode-range: U+301, U+400-45F, U+490-491, U+4B0-4B1, U+2116; }

@font-face { font-family: "JetBrains Mono"; font-style: normal; font-weight: 700; font-display: swap; src: url("https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxPcwgknk-6nFg.woff2") format("woff2"); unicode-range: U+370-377, U+37A-37F, U+384-38A, U+38C, U+38E-3A1, U+3A3-3FF; }

@font-face { font-family: "JetBrains Mono"; font-style: normal; font-weight: 700; font-display: swap; src: url("https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx_cwgknk-6nFg.woff2") format("woff2"); unicode-range: U+102-103, U+110-111, U+128-129, U+168-169, U+1A0-1A1, U+1AF-1B0, U+300-301, U+303-304, U+308-309, U+323, U+329, U+1EA0-1EF9, U+20AB; }

@font-face { font-family: "JetBrains Mono"; font-style: normal; font-weight: 700; font-display: swap; src: url("https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPx7cwgknk-6nFg.woff2") format("woff2"); unicode-range: U+100-2BA, U+2BD-2C5, U+2C7-2CC, U+2CE-2D7, U+2DD-2FF, U+304, U+308, U+329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF; }

@font-face { font-family: "JetBrains Mono"; font-style: normal; font-weight: 700; font-display: swap; src: url("https://fonts.gstatic.com/s/jetbrainsmono/v20/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxDcwgknk-4.woff2") format("woff2"); unicode-range: U+0-FF, U+131, U+152-153, U+2BB-2BC, U+2C6, U+2DA, U+2DC, U+304, U+308, U+329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; }
------MultipartBoundary--UL36Vsa5HO0TbB8lkGoRqqA9W8Bsi7tgULfaVjMKY5----
Content-Type: text/css
Content-Transfer-Encoding: binary
Content-Location: https://www.gstatic.com/_/translate_http/_/ss/k=translate_http.tr.26tY-h6gH9w.L.W.O/am=DAY/d=0/rs=AN8SPfrCcgxoBri2FVMQptvuOBiOsolgBw/m=el_main_css

@charset "utf-8";

.VIpgJd-ZVi9od-ORHb-OEVmcd { left: 0px; top: 0px; height: 39px; width: 100%; z-index: 10000001; position: fixed; border-top: none; border-right: none; border-left: none; border-image: initial; border-bottom: 1px solid rgb(107, 144, 218); margin: 0px; box-shadow: rgb(153, 153, 153) 0px 0px 8px 1px; }

.VIpgJd-ZVi9od-xl07Ob-OEVmcd { z-index: 10000002; border: none; position: fixed; box-shadow: rgb(153, 153, 153) 0px 3px 8px 2px; }

.VIpgJd-ZVi9od-SmfZ-OEVmcd { z-index: 10000000; border: none; margin: 0px; }

.goog-te-gadget { font-family: arial; font-size: 11px; color: rgb(102, 102, 102); white-space: nowrap; }

.goog-te-gadget img { vertical-align: middle; border: none; }

.goog-te-gadget-simple { background-color: rgb(255, 255, 255); border-width: 1px; border-style: solid; border-color: rgb(155, 155, 155) rgb(213, 213, 213) rgb(232, 232, 232); font-size: 10pt; display: inline-block; padding-top: 1px; padding-bottom: 2px; cursor: pointer; }

.goog-te-gadget-icon { margin-left: 2px; margin-right: 2px; width: 19px; height: 19px; border: none; vertical-align: middle; }

.goog-te-combo { margin-left: 4px; margin-right: 4px; vertical-align: baseline; }

.goog-te-gadget .goog-te-combo { margin: 4px 0px; }

.VIpgJd-ZVi9od-l4eHX-hSRGPd, .VIpgJd-ZVi9od-l4eHX-hSRGPd:link, .VIpgJd-ZVi9od-l4eHX-hSRGPd:visited, .VIpgJd-ZVi9od-l4eHX-hSRGPd:hover, .VIpgJd-ZVi9od-l4eHX-hSRGPd:active { font-size: 12px; font-weight: bold; color: rgb(68, 68, 68); text-decoration: none; }

.VIpgJd-ZVi9od-ORHb .VIpgJd-ZVi9od-l4eHX-hSRGPd, .VIpgJd-ZVi9od-TvD9Pc-hSRGPd { display: block; margin: 0px 10px; }

.VIpgJd-ZVi9od-ORHb .VIpgJd-ZVi9od-l4eHX-hSRGPd { padding-top: 2px; padding-left: 4px; }

.goog-te-combo, .VIpgJd-ZVi9od-ORHb *, .VIpgJd-ZVi9od-SmfZ *, .VIpgJd-ZVi9od-xl07Ob *, .VIpgJd-ZVi9od-vH1Gmf *, .VIpgJd-ZVi9od-l9xktf * { font-family: arial; font-size: 10pt; }

.VIpgJd-ZVi9od-ORHb { margin: 0px; background-color: rgb(228, 239, 251); overflow: hidden; }

.VIpgJd-ZVi9od-ORHb img { border: none; }

.VIpgJd-ZVi9od-ORHb-bN97Pc { color: rgb(0, 0, 0); }

.VIpgJd-ZVi9od-ORHb-bN97Pc img { vertical-align: middle; }

.VIpgJd-ZVi9od-ORHb-Tswv1b { color: rgb(102, 102, 102); vertical-align: top; margin-top: 0px; font-size: 7pt; }

.VIpgJd-ZVi9od-ORHb-KE6vqe { width: 8px; }

.VIpgJd-ZVi9od-LgbsSe { border-color: rgb(231, 231, 231); border-style: none solid solid none; border-width: 0px 1px 1px 0px; }

.VIpgJd-ZVi9od-LgbsSe div { border-color: rgb(204, 204, 204) rgb(153, 153, 153) rgb(153, 153, 153) rgb(204, 204, 204); border-style: solid; border-width: 1px; height: 20px; }

.VIpgJd-ZVi9od-LgbsSe button { background: transparent; border: none; cursor: pointer; height: 20px; overflow: hidden; margin: 0px; vertical-align: top; white-space: nowrap; }

.VIpgJd-ZVi9od-LgbsSe button:active { background: none 0px 0px repeat scroll rgb(204, 204, 204); }

.VIpgJd-ZVi9od-SmfZ { margin: 0px; background-color: rgb(255, 255, 255); white-space: nowrap; }

.VIpgJd-ZVi9od-SmfZ-hSRGPd { text-decoration: none; font-weight: bold; font-size: 10pt; border: 1px outset rgb(136, 136, 136); padding: 6px 10px; white-space: nowrap; position: absolute; left: 0px; top: 0px; }

.VIpgJd-ZVi9od-SmfZ-hSRGPd img { margin-left: 2px; margin-right: 2px; width: 19px; height: 19px; border: none; vertical-align: middle; }

.VIpgJd-ZVi9od-SmfZ-hSRGPd span { text-decoration: underline; margin-left: 2px; margin-right: 2px; vertical-align: middle; }

.goog-te-float-top .VIpgJd-ZVi9od-SmfZ-hSRGPd { padding: 2px; border-top-width: 0px; }

.goog-te-float-bottom .VIpgJd-ZVi9od-SmfZ-hSRGPd { padding: 2px; border-bottom-width: 0px; }

.VIpgJd-ZVi9od-xl07Ob-lTBxed { text-decoration: none; color: rgb(0, 0, 204); white-space: nowrap; margin-left: 4px; margin-right: 4px; }

.VIpgJd-ZVi9od-xl07Ob-lTBxed span { text-decoration: underline; }

.VIpgJd-ZVi9od-xl07Ob-lTBxed img { margin-left: 2px; margin-right: 2px; }

.goog-te-gadget-simple .VIpgJd-ZVi9od-xl07Ob-lTBxed { color: rgb(0, 0, 0); }

.goog-te-gadget-simple .VIpgJd-ZVi9od-xl07Ob-lTBxed span { text-decoration: none; }

.VIpgJd-ZVi9od-xl07Ob { background-color: rgb(255, 255, 255); text-decoration: none; border: 2px solid rgb(195, 217, 255); overflow: hidden scroll; position: absolute; left: 0px; top: 0px; }

.VIpgJd-ZVi9od-xl07Ob-ibnC6b { padding: 3px; text-decoration: none; }

.VIpgJd-ZVi9od-xl07Ob-ibnC6b, .VIpgJd-ZVi9od-xl07Ob-ibnC6b:link { color: rgb(0, 0, 204); background: rgb(255, 255, 255); }

.VIpgJd-ZVi9od-xl07Ob-ibnC6b:visited { color: rgb(85, 26, 139); }

.VIpgJd-ZVi9od-xl07Ob-ibnC6b:hover { background: rgb(195, 217, 255); }

.VIpgJd-ZVi9od-xl07Ob-ibnC6b:active { color: rgb(0, 0, 204); }

.VIpgJd-ZVi9od-vH1Gmf { background-color: rgb(255, 255, 255); text-decoration: none; border: 1px solid rgb(107, 144, 218); overflow: hidden; padding: 4px; }

.VIpgJd-ZVi9od-vH1Gmf-KrhPNb { width: 16px; }

.VIpgJd-ZVi9od-vH1Gmf-hgDUwe { margin: 6px 0px; height: 1px; background-color: rgb(170, 170, 170); overflow: hidden; }

.VIpgJd-ZVi9od-vH1Gmf-ibnC6b div, .VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd div { padding: 4px; }

.VIpgJd-ZVi9od-vH1Gmf-ibnC6b .uDEFge { display: none; }

.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd .uDEFge { }

.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd .fmcmS { padding-left: 4px; padding-right: 4px; }

.VIpgJd-ZVi9od-vH1Gmf-ibnC6b, .VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd { text-decoration: none; }

.VIpgJd-ZVi9od-vH1Gmf-ibnC6b div, .VIpgJd-ZVi9od-vH1Gmf-ibnC6b:link div, .VIpgJd-ZVi9od-vH1Gmf-ibnC6b:visited div, .VIpgJd-ZVi9od-vH1Gmf-ibnC6b:active div { color: rgb(0, 0, 204); background: rgb(255, 255, 255); }

.VIpgJd-ZVi9od-vH1Gmf-ibnC6b:hover div { color: rgb(255, 255, 255); background: rgb(51, 102, 204); }

.VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd div, .VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:link div, .VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:visited div, .VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:hover div, .VIpgJd-ZVi9od-vH1Gmf-ibnC6b-gk6SMd:active div { color: rgb(0, 0, 0); font-weight: bold; }

.VIpgJd-ZVi9od-l9xktf { background-color: rgb(255, 255, 255); overflow: hidden; padding: 8px; border: none; border-radius: 10px; }

.VIpgJd-ZVi9od-l9xktf-OEVmcd { background-color: rgb(255, 255, 255); border: 1px solid rgb(107, 144, 218); box-shadow: rgb(153, 153, 153) 0px 3px 8px 2px; border-radius: 8px; }

.VIpgJd-ZVi9od-l9xktf img { border: none; }

.VIpgJd-ZVi9od-l9xktf-fmcmS { margin-top: 6px; }

.VIpgJd-ZVi9od-l9xktf-VgwJlc { margin-top: 6px; white-space: nowrap; }

.VIpgJd-ZVi9od-l9xktf-VgwJlc * { vertical-align: middle; }

.VIpgJd-ZVi9od-l9xktf-VgwJlc .DUGJie { background-image: url("https://www&google.com/images/zippy_minus_sm.gif"); }

.VIpgJd-ZVi9od-l9xktf-VgwJlc .TdyTDe { background-image: url("https://www&google.com/images/zippy_plus_sm.gif"); }

.VIpgJd-ZVi9od-l9xktf-VgwJlc span { color: rgb(0, 0, 204); text-decoration: underline; cursor: pointer; margin: 0px 4px; }

.VIpgJd-ZVi9od-l9xktf-I9GLp { margin: 6px 0px 0px; }

.VIpgJd-ZVi9od-l9xktf-I9GLp form { margin: 0px; }

.VIpgJd-ZVi9od-l9xktf-I9GLp form textarea { margin-bottom: 4px; width: 100%; }

.VIpgJd-ZVi9od-l9xktf-yePe5c { margin: 6px 0px 4px; }

.VIpgJd-ZVi9od-aZ2wEe-wOHMyf { z-index: 1000; position: fixed; transition-delay: 0.6s; left: -1000px; top: -1000px; }

.VIpgJd-ZVi9od-aZ2wEe-wOHMyf-ti6hGc { transition-delay: 0s; left: -14px; top: -14px; }

.VIpgJd-ZVi9od-aZ2wEe-OiiCO { display: flex; -webkit-box-align: center; align-items: center; -webkit-box-pack: center; justify-content: center; width: 104px; height: 104px; border-radius: 50px; background: url("https://www.gstatic.com/images/branding/product/2x/translate_24dp.png") 50% 50% no-repeat rgb(255, 255, 255); transition: all 0.6s ease-in-out 0s; transform: scale(0.4); opacity: 0; }

.VIpgJd-ZVi9od-aZ2wEe-OiiCO-ti6hGc { transform: scale(0.5); opacity: 1; }

.VIpgJd-ZVi9od-aZ2wEe { margin: 2px 0px 0px 2px; animation: 1.4s linear 0s infinite normal none running spinner-rotator; }

@-webkit-keyframes spinner-rotator { 
  0% { transform: rotate(0deg); }
  100% { transform: rotate(270deg); }
}

@keyframes spinner-rotator { 
  0% { transform: rotate(0deg); }
  100% { transform: rotate(270deg); }
}

.VIpgJd-ZVi9od-aZ2wEe-Jt5cK { stroke-dasharray: 187; stroke-dashoffset: 0; stroke: rgb(66, 133, 244); transform-origin: center center; animation: 1.4s ease-in-out 0s infinite normal none running spinner-dash; }

@-webkit-keyframes spinner-dash { 
  0% { stroke-dashoffset: 187; }
  50% { stroke-dashoffset: 46.75; transform: rotate(135deg); }
  100% { stroke-dashoffset: 187; transform: rotate(450deg); }
}

@keyframes spinner-dash { 
  0% { stroke-dashoffset: 187; }
  50% { stroke-dashoffset: 46.75; transform: rotate(135deg); }
  100% { stroke-dashoffset: 187; transform: rotate(450deg); }
}

.VIpgJd-yAWNEb-L7lbkb html, .VIpgJd-yAWNEb-L7lbkb body, .VIpgJd-yAWNEb-L7lbkb div, .VIpgJd-yAWNEb-L7lbkb span, .VIpgJd-yAWNEb-L7lbkb iframe, .VIpgJd-yAWNEb-L7lbkb h1, .VIpgJd-yAWNEb-L7lbkb h2, .VIpgJd-yAWNEb-L7lbkb h3, .VIpgJd-yAWNEb-L7lbkb h4, .VIpgJd-yAWNEb-L7lbkb h5, .VIpgJd-yAWNEb-L7lbkb h6, .VIpgJd-yAWNEb-L7lbkb p, .VIpgJd-yAWNEb-L7lbkb a, .VIpgJd-yAWNEb-L7lbkb img, .VIpgJd-yAWNEb-L7lbkb ol, .VIpgJd-yAWNEb-L7lbkb ul, .VIpgJd-yAWNEb-L7lbkb li, .VIpgJd-yAWNEb-L7lbkb table, .VIpgJd-yAWNEb-L7lbkb form, .VIpgJd-yAWNEb-L7lbkb tbody, .VIpgJd-yAWNEb-L7lbkb tr, .VIpgJd-yAWNEb-L7lbkb td { margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-family: inherit; font-optical-sizing: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; font-size: 100%; vertical-align: baseline; text-align: left; line-height: normal; }

.VIpgJd-yAWNEb-L7lbkb ol, .VIpgJd-yAWNEb-L7lbkb ul { list-style: none; }

.VIpgJd-yAWNEb-L7lbkb table { border-collapse: collapse; border-spacing: 0px; }

.VIpgJd-yAWNEb-L7lbkb caption, .VIpgJd-yAWNEb-L7lbkb th, .VIpgJd-yAWNEb-L7lbkb td { text-align: left; font-weight: normal; }

div > .VIpgJd-yAWNEb-L7lbkb { padding: 10px 14px; }

.VIpgJd-yAWNEb-L7lbkb { color: rgb(34, 34, 34); background-color: rgb(255, 255, 255); border: 1px solid rgb(238, 238, 238); box-shadow: rgba(0, 0, 0, 0.2) 0px 4px 16px; display: none; font-family: arial; font-size: 10pt; width: 420px; padding: 12px; position: absolute; z-index: 10000; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-nVMfcd-fmcmS, .VIpgJd-yAWNEb-yAWNEb-Vy2Aqc-pbTTYe { clear: both; font-size: 10pt; position: relative; text-align: justify; width: 100%; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-r4nke { color: rgb(153, 153, 153); font-family: arial, sans-serif; margin: 4px 0px; text-align: left; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TvD9Pc-LgbsSe { display: none; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-l4eHX { float: left; margin: 0px; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-PLDbbf { display: inline-block; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-fw42Ze-Z0Arqf-haAclf { display: none; width: 100%; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-H9tDt { margin-top: 20px; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-LK5yu { float: left; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-qwU8Me { float: right; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-cGMI2b { min-height: 15px; position: relative; height: 1%; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-jOfkMb-Ne3sFf { background: rgb(41, 145, 13); border-radius: 4px; box-shadow: rgb(30, 102, 9) 0px 2px 2px inset; color: white; font-size: 9pt; font-weight: bolder; margin-top: 12px; padding: 6px; text-shadow: rgb(30, 102, 9) 1px 1px 1px; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-hSRGPd { color: rgb(17, 85, 204); cursor: pointer; font-family: arial; font-size: 11px; margin-right: 15px; text-decoration: none; }

.VIpgJd-yAWNEb-L7lbkb > textarea { font-family: arial; resize: vertical; width: 100%; margin-bottom: 10px; border-radius: 1px; border-width: 1px; border-style: solid; border-color: silver rgb(217, 217, 217) rgb(217, 217, 217); border-image: initial; font-size: 13px; height: auto; overflow-y: auto; padding: 1px; }

.VIpgJd-yAWNEb-L7lbkb textarea:focus { box-shadow: rgba(0, 0, 0, 0.3) 0px 1px 2px inset; border: 1px solid rgb(77, 144, 254); outline: none; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-Z0Arqf-IbE0S { margin-right: 10px; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp { min-height: 25px; vertical-align: middle; padding-top: 8px; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp { margin-bottom: 0px; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input { display: inline-block; min-width: 54px; border: 1px solid rgba(0, 0, 0, 0.1); text-align: center; color: rgb(68, 68, 68); font-size: 11px; font-weight: bold; height: 27px; outline: 0px; padding: 0px 8px; vertical-align: middle; line-height: 27px; margin: 0px 16px 0px 0px; box-shadow: rgba(0, 0, 0, 0.1) 0px 1px 2px; border-radius: 2px; transition: all 0.218s ease 0s; background-color: rgb(245, 245, 245); background-image: -webkit-linear-gradient(top, rgb(245, 245, 245), rgb(241, 241, 241)); user-select: none; cursor: default; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:hover { border: 1px solid rgb(198, 198, 198); color: rgb(34, 34, 34); transition: all 0s ease 0s; background-color: rgb(248, 248, 248); background-image: -webkit-linear-gradient(top, rgb(248, 248, 248), rgb(241, 241, 241)); }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:active { border: 1px solid rgb(198, 198, 198); color: rgb(51, 51, 51); background-color: rgb(246, 246, 246); background-image: -webkit-linear-gradient(top, rgb(246, 246, 246), rgb(241, 241, 241)); }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.AHmuwe .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:active, .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus:active { box-shadow: rgba(255, 255, 255, 0.5) 0px 0px 0px 1px inset; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus, .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.AHmuwe { outline: none; border: 1px solid rgb(77, 144, 254); z-index: 4 !important; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.gk6SMd { background-color: rgb(238, 238, 238); background-image: -webkit-linear-gradient(top, rgb(238, 238, 238), rgb(224, 224, 224)); box-shadow: rgba(0, 0, 0, 0.1) 0px 1px 2px inset; border: 1px solid rgb(204, 204, 204); color: rgb(51, 51, 51); }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf { color: white; border-color: rgb(48, 121, 237); background-color: rgb(77, 144, 254); background-image: -webkit-linear-gradient(top, rgb(77, 144, 254), rgb(71, 135, 237)); }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:hover .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:focus, .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf.AHmuwe .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:active { border-color: rgb(48, 121, 237); background-color: rgb(53, 122, 232); background-image: -webkit-linear-gradient(top, rgb(77, 144, 254), rgb(53, 122, 232)); }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:hover { box-shadow: rgb(255, 255, 255) 0px 0px 0px 1px inset, rgba(0, 0, 0, 0.1) 0px 1px 1px; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:focus, .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input.AHmuwe, .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:active, .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input:hover, .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:focus, .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf.AHmuwe, .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:active, .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-L4Nn5e-I9GLp .VIpgJd-yAWNEb-Z0Arqf-I9GLp input .VIpgJd-yAWNEb-Z0Arqf-sFeBqf:hover { border-color: rgb(48, 121, 237); }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-mrxPge { color: rgb(153, 153, 153); font-family: arial, sans-serif; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-W0vJo-fmcmS { color: rgb(153, 153, 153); font-size: 11px; font-family: arial, sans-serif; margin: 15px 0px 5px; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-u0pjoe-fmcmS { color: rgb(136, 0, 0); display: none; font-size: 9pt; }

.VIpgJd-yAWNEb-VIpgJd-fmcmS-sn54Q { background-color: rgb(201, 215, 241); box-shadow: rgb(153, 153, 170) 2px 2px 4px; box-sizing: border-box; position: relative; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-xl07Ob { background: rgb(255, 255, 255); border: 1px solid rgb(221, 221, 221); box-shadow: rgb(153, 153, 170) 0px 2px 4px; min-width: 0px; outline: none; padding: 0px; position: absolute; z-index: 2000; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb { cursor: pointer; padding: 2px 5px 5px; margin-right: 0px; border-style: none; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb:hover { background: rgb(221, 221, 221); }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb h1 { font-size: 100%; font-weight: bold; margin: 4px 0px; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-xl07Ob .VIpgJd-yAWNEb-VIpgJd-j7LFlb strong { color: rgb(52, 90, 173); }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-VIpgJd-eKm5Fc-hFsbo { text-align: right; position: absolute; right: 0px; left: auto; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-VIpgJd-j7LFlb-SIsrTd .VIpgJd-yAWNEb-VIpgJd-eKm5Fc-hFsbo { text-align: left; position: absolute; left: 0px; right: auto; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-Vy2Aqc-fmcmS, .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf-sn54Q { background-color: rgb(241, 234, 0); border-radius: 4px; box-shadow: rgba(0, 0, 0, 0.5) 3px 3px 4px; box-sizing: border-box; color: rgb(241, 234, 0); cursor: pointer; margin: -2px -2px -2px -3px; padding: 2px 2px 2px 3px; position: relative; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf-sn54Q { color: rgb(34, 34, 34); }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-Vy2Aqc-pbTTYe { color: white; position: absolute !important; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf, .VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-ppHlrf .VIpgJd-yAWNEb-TVLw9c-ppHlrf-sn54Q { background-color: rgb(201, 215, 241); border-radius: 4px 4px 0px 0px; box-shadow: rgba(0, 0, 0, 0.5) 3px 3px 4px; box-sizing: border-box; cursor: pointer; margin: -2px -2px -2px -3px; padding: 2px 2px 3px 3px; position: relative; }

.VIpgJd-yAWNEb-L7lbkb span:focus { outline: none; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-TVLw9c-DyVDA { background-color: transparent; border: 1px solid rgb(77, 144, 254); border-radius: 0px; margin: -2px; padding: 1px; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-TVLw9c-sn54Q-LzX3ef { border-left: 2px solid red; margin-left: -2px; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-yAWNEb-TVLw9c-sn54Q-YIAiIb { border-right: 2px solid red; margin-right: -2px; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf { padding: 2px; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-fmcmS { font-size: 11px; padding: 2px 2px 3px; margin: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); border-width: 1px; border-style: solid; border-color: rgb(192, 192, 192) rgb(217, 217, 217) rgb(217, 217, 217); border-image: initial; display: inline-block; vertical-align: top; height: 21px; box-sizing: border-box; border-radius: 1px; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-fmcmS:hover { border-width: 1px; border-style: solid; border-color: rgb(160, 160, 160) rgb(185, 185, 185) rgb(185, 185, 185); border-image: initial; box-shadow: rgba(0, 0, 0, 0.1) 0px 1px 2px inset; }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-fmcmS:focus { box-shadow: rgba(0, 0, 0, 0.3) 0px 1px 2px inset; outline: none; border: 1px solid rgb(77, 144, 254); }

.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-IFdKyd-YPqjbf-sFeBqf { font-size: 11px; padding: 2px 6px 3px; margin: 0px 0px 0px 2px; height: 21px; }

.VIpgJd-yAWNEb-hvhgNd { font-family: "Google Sans", Arial, sans-serif; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-l4eHX-i3jM8c { position: absolute; top: 10px; left: 14px; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-l4eHX-SIsrTd { position: absolute; top: 10px; right: 14px; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-i3jM8c, .VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-SIsrTd { margin: 16px; padding: 0px; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-IuizWc { margin: 0px 0px 0px 36px; padding: 0px; color: rgb(116, 119, 117); font-size: 14px; font-weight: 500; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-SIsrTd .VIpgJd-yAWNEb-hvhgNd-IuizWc { text-align: right; margin: 0px 36px 0px 0px; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-axAV1 { width: auto; padding: 12px 0px 0px; color: rgb(31, 31, 31); font-size: 16px; text-align: initial; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-axAV1 .VIpgJd-yAWNEb-SIsrTd { text-align: right; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid { border-radius: 0px 0px 12px 12px; margin: 0px; background: rgb(241, 244, 249); position: relative; min-height: 50px; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid .VIpgJd-yAWNEb-SIsrTd { text-align: right; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od { display: inline-block; width: 77%; padding: 12px; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od .VIpgJd-yAWNEb-SIsrTd { text-align: right; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-UTujCb { color: rgb(31, 31, 31); font-size: 12px; font-weight: 500; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od .VIpgJd-yAWNEb-SIsrTd .VIpgJd-yAWNEb-hvhgNd-UTujCb { text-align: right; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-eO9mKe { color: rgb(68, 71, 70); font-size: 12px; padding-top: 4px; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od .VIpgJd-yAWNEb-SIsrTd .VIpgJd-yAWNEb-hvhgNd-eO9mKe { text-align: right; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-xgov5 { position: absolute; top: 10px; right: 5px; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-xgov5 .VIpgJd-yAWNEb-SIsrTd { left: 5px; right: auto; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-THI6Vb { fill: rgb(11, 87, 208); }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-bgm6sf { margin: -4px 2px 0px 0px; padding: 2px 0px 0px; width: 48px; height: 48px; border: none; border-radius: 24px; cursor: pointer; background: none; }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-bgm6sf:hover { background: rgb(232, 235, 236); }

.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-aXYTce { display: none; }

sentinel { }
------MultipartBoundary--UL36Vsa5HO0TbB8lkGoRqqA9W8Bsi7tgULfaVjMKY5----
Content-Type: image/svg+xml
Content-Transfer-Encoding: binary
Content-Location: https://fonts.gstatic.com/s/i/productlogos/translate/v14/24px.svg

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><defs><path d="M21.5 5h-9.17L11 1H2.5C1.68 1 1 1.68 1 2.5v15c0 .83.68 1.5 1.5 1.5h9.17L13 23h8.5c.82 0 1.5-.68 1.5-1.5v-15c0-.83-.68-1.5-1.5-1.5z" id="a"/></defs><clipPath id="b"><use overflow="visible" xlink:href="#a"/></clipPath><g clip-path="url(#b)"><image height="31" opacity=".2" overflow="visible" transform="translate(3 1)" width="29" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAfCAYAAAAbW8YEAAAACXBIWXMAAAsSAAALEgHS3X78AAAA GXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABQBJREFUeNq8V8tu20YUvXdm+LCk RKiMwI1TFEXhVZJd1gW66xekv9DPqPsvXdU/UaDroJskKy+CInCcGpKtFy2SM/f2DEXZia0odtKW AkFJ8zhzzn3S0Ycvps+79EMDbj3Yfgv4EM+XTN/fEOb3Zg3AXmq7j64D5/e/x/EfzZMnX5jx+LFZ LLyp6yNDOzskYb6RubFdpbdvKUl2Jc+d9PvP5dmzUyH6TVoYXQOq+H5g9vb+cONsO9maLpIyyZPU kZNAppmh9Vpg5kSXwCSVJ5/Vi/r8Tl73y2F9ePidJ3oaga+B4vkUgF+6EW1ndz11gvNdDdL1bDNr yKkCWO16thyUGWIIeae2ZGvn1of5xFExoGF5eHgM4ANZsW032Tf05MjeW+xmNKeedeWAg9tmywPM 6rGYzOAPBSfQ5Ss0Nf4pAmRrSmBP1ehIxQ6DpxF1aXaSH5X0bDcAR1aOxLRPtPdrZrwnd55Sx3gz IMO72OwBq9kmox0RSkHHRNxrRJWFDbQXKpR1xN4eOfx0NqnMdFHulY/rw/1RAE5crEvvffGCvX/E VUoOC3Mm24eaO6TyNZjeB5E+sDLMt2tCqZEW8lcgPSU2x0IhKlAYoTP4xUTueUMvHvJK3ouQ8ffH HP62JpGeg/VSYciqNADbHQxvY5etdr65yhNXlG2B5xjzgWfHJoSeZ5Olbuaq+czQyYSvxal701dJ SWoigRNqXItjORhsC+x74NfDtPQ6aGPkgAUlGROpTKBQR4gbB1x6fjz3/DK8GsoHj/SVG6pJACi+ NhQdApsQJFPCeliYKImgeEJmylc3Xzw5yp9xnIMYMkZt9HjVhK/GeHtqZI5+KUVJXtSVQcwcYDPo FI93jhW+DWSjzZrGts0NQSwOZTFoMaMBaly6CTFZG2KXUt3Z1aQzC36rKrFJ0cgUb6aZRnuRwjtI lo7Eq3CLWSya4eJ7a+TN2eudvClbk17ItFepoQLrpyQyxkZTjBYIiwqnXwF/1mXerQivtu+Hohp7 tf7cWJnCTgBleCQ3bBEaPiaCTRXkNqBLu955o2kv+NzIIogDkGlAEfuwL51DYh9z3sdK1y1ALyX2 FxJLK3Fj339NYnO16P4fEl8J9HUSaytxTHFRYqrhnJ60AZU2lNpDNOULaZH1FqBXJS4LhN8ECeos MgbLWUx3AK+xv4+ZKN6ACxxlZw0xDzdZKj7Z6E1ALyQ+91WNclwgIU6wwRli7xTkzjA8BQCSBxfL +MUhlnGMDMYlfsPuWsdSF4GZa226io1MW4nzPvkQbWgDnIlGYHSCTU+QbOI9BNtTTB7hxmEIh+FT KDJGZoiVpkA6KmNRj90E0duPNmaNxJ29QVh0RxWsOMNRh0JyDIk7LBK1iw62BV1cLKaXpY2n+HWs GkZidOZEysp3fDK4K3TvK90EisGf6bD/k6CTqDpBZt6EoTWcSXQU5mhX1FvNm/XRiyQiaw0XKmDi EXL9kdV6FMMu9kvpyUDoB3SIB5uYxp2+fSr9P7Na7IOipsUpxZ5BqISNTw1rFy6bGrKoIjAbS9uu EKoT2NowqiWJ7cqM0KD9lT8X2t+lKz3S2l4Z/e4v9ptXzcFyn9Zd8nlHHcjXaNZsaCvKqlW6dWP2 Ibr7sdE2e68H9sy+TvN5J6nwydLUvtuWfmoLugH4Zg34JzbbHwO/wavG+68VdJPXihuC/zcvUJ+0 0W2ufwQYAGHKK2CFMIrzAAAAAElFTkSuQmCC"/><radialGradient cx="7.394" cy="5.437" gradientUnits="userSpaceOnUse" id="c" r="23.416"><stop offset="0" stop-color="#EEE"/><stop offset=".432" stop-color="#E6E6E6"/><stop offset="1" stop-color="#E1E1E1"/></radialGradient><path d="M13 23h8.5c.82 0 1.5-.68 1.5-1.5v-15c0-.83-.68-1.5-1.5-1.5H7l6 18z" fill="url(#c)"/></g><path clip-path="url(#b)" d="M18 11v-1h-1v1h-3.75v1h5.32c-.2.49-.6 1.3-1.32 2.14-.51-.6-.86-1.18-1.1-1.64h-1.11c.36.84.9 1.66 1.52 2.38l-2.6 2.58.71.71 2.58-2.58 2.58 2.58.71-.71-2.6-2.58c.74-.86 1.33-1.85 1.68-2.88H21v-1h-3z" fill="#607D8B"/><linearGradient gradientUnits="userSpaceOnUse" id="d" x1="12.333" x2="23" y1="14" y2="14"><stop offset="0" stop-color="#212121" stop-opacity=".1"/><stop offset="1" stop-color="#212121" stop-opacity=".02"/></linearGradient><path clip-path="url(#b)" d="M12.33 5L23 15.67V23H13" fill="url(#d)"/><g clip-path="url(#b)"><image height="8" opacity=".1" overflow="visible" transform="translate(10.5 17.5)" width="9" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAJCAYAAAALpr0TAAAACXBIWXMAAAsSAAALEgHS3X78AAAA GXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAOFJREFUeNp0UD1LA0EUnLe7JsJh CiFpLVNYaS3411L7Z/InUpgmqRIRLGxEOEVQsoRcbnecu6AGTB4M72vevjdr+DPDf+Nvs3858q7a Fp4oDOZBJ5dJMCVDzJ2T+LYYpeAyTj39UMNXhA00HABXKy89bY6UlqrFoMHm5QK0a/mbXYxSyyZm eCBTe5Kr68+NGq+Kv4QzoSM8q3ZP8imjXjdEv/6Ysnd+q6a7UN4XFsKYlifbUJXvj3ftytAqM1vJ z6UgGvgiIbN90g8RVddFKZ/pzqX+Y5NDtdonHTI71vgWYADzWmdx/4fpmQAAAABJRU5ErkJggg=="/><path d="M17 19l-4 4-1.33-4" fill="#3F51B5"/></g><path clip-path="url(#b)" d="M21.5 5H7l.04.12H21.5c.82 0 1.5.67 1.5 1.5V6.5c0-.83-.68-1.5-1.5-1.5z" fill="#212121" fill-opacity=".02"/><path clip-path="url(#b)" d="M21.5 22.88H13L11.71 19h-.04L13 23h8.5c.82 0 1.5-.68 1.5-1.5v-.12c0 .82-.68 1.5-1.5 1.5z" fill="#212121" fill-opacity=".1"/><path clip-path="url(#b)" d="M12.97 22.91L13 23l4-4h-.12" fill="#1A237E" fill-opacity=".2"/><path clip-path="url(#b)" d="M11.67 19.12h5.21L17 19h-5.33" fill="#1A237E" fill-opacity=".1"/><g clip-path="url(#b)"><image height="22" opacity=".2" overflow="visible" transform="translate(-.5 -.5)" width="20" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAXCAYAAADk3wSdAAAACXBIWXMAAAsSAAALEgHS3X78AAAA GXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAUpJREFUeNqslbFOwzAQQO/sQCRc sqAOlRgrMjCVr+Er+IZ+Ax/WTCwVeyVQl9IOQY2Pc2qhNFwcGsdSrHNsP52fpTPCeUP4X6PQZA2Z Pi41lqXRpCYKtA5tsFBVFdo9penh821ZSWsS112X1hBdPXG44BSyQMaEoHcJ6QJLu+LxrguKQDQB UAuOn3nfLATlqc0psmvuvyQVibfARyaXoQPeh6Hk9Mw4uL2bv3xs31+P7UWq5Rd7LsvN8akg5zBP KTPSIgWXN3OCQo6ARkpiCNQd36maegV6DGgjW1lBJFRWMBQaVDAUGlQwAvSvghhop4IYaKeCkaDn CmKhooJYqKhAtao59VV1od3w99BU4EsfcQVXruBuPBMvgJIv1sdmPSVA3HOhLvy/bCC0qDk8rjP9 TtWB36gVv1Hrvjeq792SjokRF/Z7Fz8CDAC8EmWDKVGDLgAAAABJRU5ErkJggg=="/><path d="M11 1H2.5C1.68 1 1 1.68 1 2.5v15c0 .83.68 1.5 1.5 1.5H17L11 1z" fill="#4285F4"/></g><path clip-path="url(#b)" d="M2.5 1C1.68 1 1 1.68 1 2.5v.12c0-.82.68-1.5 1.5-1.5H11V1H2.5z" fill="#FFF" fill-opacity=".02"/><path clip-path="url(#b)" d="M11 1v.12l5.92 17.75H2.5c-.82 0-1.5-.67-1.5-1.5v.12c0 .84.68 1.51 1.5 1.51H17L11 1z" fill="#212121" fill-opacity=".1"/><g clip-path="url(#b)"><path d="M7.5 10v1.2h1.98c-.08.52-.6 1.51-1.98 1.51-1.2 0-2.17-.99-2.17-2.21S6.3 8.29 7.5 8.29c.68 0 1.13.29 1.39.54l.95-.92C9.24 7.35 8.44 7 7.5 7 5.57 7 4 8.57 4 10.5S5.57 14 7.5 14c2.02 0 3.36-1.42 3.36-3.42 0-.23-.02-.41-.06-.58H7.5z" fill="#EEE"/><path d="M4 7h7v7H4z" fill="none"/></g><radialGradient cx="1.457" cy="1.42" gradientUnits="userSpaceOnUse" id="e" r="29.792"><stop offset="0" stop-color="#FFF" stop-opacity=".1"/><stop offset="1" stop-color="#FFF" stop-opacity="0"/></radialGradient><path d="M21.5 5h-9.17L11 1H2.5C1.68 1 1 1.68 1 2.5v15c0 .83.68 1.5 1.5 1.5h9.17L13 23h8.5c.82 0 1.5-.68 1.5-1.5v-15c0-.83-.68-1.5-1.5-1.5z" fill="url(#e)"/></svg>
------MultipartBoundary--UL36Vsa5HO0TbB8lkGoRqqA9W8Bsi7tgULfaVjMKY5----
Content-Type: text/html
Content-ID: <frame-EED1E357ED4C3E8CBC8C8F38614C4F52@mhtml.blink>
Content-Transfer-Encoding: binary

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></head><body></body></html>
------MultipartBoundary--UL36Vsa5HO0TbB8lkGoRqqA9W8Bsi7tgULfaVjMKY5------
